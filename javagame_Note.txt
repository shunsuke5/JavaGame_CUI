javaゲーム メモ

・文章が表示される間隔を2秒ぐらいにしたい
　(欲を言えばクリックするごとに表示させたい)

・フィールドで勇者のaction()メソッドを呼び出す感じにする。
　action()メソッドは、どのアクションを行いますか？と表示し
　討伐、探索、休む、マップ移動などを選択肢で表示する。

・while (イベントカウント) {
    action();
    
}

・各フィールドのクリア条件は、討伐と探索を決められた回数クリアしたらにする
　決められた回数クリアしたら強制的にイベントに進ませるのではなく、
　mapActionに「ボス戦」の選択肢を追加する
　「(マップの奥地が解放された！十分な準備をしてからここに進もう」などのテキスト)

・3つあるフィールドはそれぞれ微妙に難易度が違うようにするのか、
　それとも同じようにするのか。

・探索はお宝を得られるチャンスのため、リスクがあった方がおもしろいのでは？
　中ボスを配置するなど

・どうのつるぎ、はがねのつるぎなどはmainプログラムの方で生み出す感じとなる。

・ターン制バトルをどうやって実現する？

・while(勇者のHPが0になるか、敵のHPが0になるか、どちらかが逃げるか) {
    battle();
}

・勇者の最大HPはどのように定義すればよいのか？ → 勇者クラスに専用の変数を定義
　レベルアップの時だけこの変数を呼び出すようにする。

・じゅもんを選択したがやはり違うことをしたいなどといったときに、
　もどれるプログラムもほしい

・レベル上限は20とする

・[進捗]battle()メソッドに渡す敵の引数について、マップごとに敵情報を変えて渡すにはどうすればよいか？
　　　　

・敵を倒した時に1体の敵を倒したときと複数の敵を倒した時の挙動を変えるには？？
　そもそもbattle()メソッドに複数の敵インスタンスを渡したい時にはどうすればよいのか？
　敵の数という情報は配列の形にした方が良い？
　それならbattle(Enemy[] e) とすればその配列の中身が単体でも複数でも想定しているプログラムになるはず
　「e[0].name + "と" e[1].nameをたおした！」のような記述になる
　ただ問題点が1つ、同じモンスターを複数倒した場合に「スライムとスライムをたおした！」ではおかしいので
　equals()のようなメソッドを用いて渡された配列内のモンスター名を等価か判断する必要が出てくる。

    if (配列内のモンスター名が重複していない場合){
        System.out.println(e[0].name + "と" + e[1].name + "をたおした！");
    } else {
        System.out.println(e[0].name + "をたおした！");
    }

　なお、上記のプログラムは2体を想定しているので数が増えればもっと複雑になる
　まあ簡単なゲームなので敵の最大数は3体でもいいし、このゲームはドラクエ1ライクのつもりなので
　なんなら敵は全て単体でもよい

　ちなみにもしこのプログラムを利用するならば、敵が生成される時に配列に入れる順番は
　名前を辞書順で入れると同じモンスターは必ずインデックスが連番で入るので
　それを利用して重複を確かめることにすると楽になるかも

・levelList.addももうちょい見やすく短い方法で記述できたら良い
　for文で決まった数だけ上乗せしていって周回数が一定の回数になったら
　さらに必要経験値を上乗せしていくなど
　この形のようにレベルが上がれば上がるほど必要経験値も上がっていく
　"比例"のようなプログラムを作るにはどうしたらよいのか？
　y(必要経験値) = ( 〇(現在のレベル) * x(定数) )
　上記のような形でいけるか？今回は以下の式を採用

    while (int i < 21;) {
        levelList.add(levelPoint)
        levelPoint = (int)( (levelPoint + this.level) * 1.25);
        i++
    }

・Spell healSpell = new HealSpell();
　Spell attackSpell = new AttackSpell();
　で勇者が持つ呪文インスタンスを2種類に分けて生み出し、使う時は
　brave.healSpell.hoimi();　のようにして呼び出す。

・仮に呪文の上限が5個だとして、(ホイミ(3)、メラ(5)、ベホイミ(9)、メラミ(14)、メラゾーマ(17))
　呪文一覧を表示する際にレベルアップの状況に応じてその時点で習得している呪文を表示するには？
　レベルアップのメソッドに呪文を紐づける必要がある。そして、勇者クラスに呪文一覧表示のフォーマットを
　作成し、レベルアップのときに呪文を表示するフォーマットに習得した呪文を増やすプログラムを書く必要がある。

・経験値とレベルはマップにして対応表みたいな形で扱えばよいのでは？(むずそうなので保留)

・呪文に番号を振る形に決定する。

    switch(spellChoice) {
        case 1:
            healSpell.hoimi();
            break;
        case 2:
            attackSpell.mera();
            break;
        case 3:
            healSpell.behoimi();
            break;
        case 4:
            attackSpell.merami();
            break;
        case 5:
            attackSpell.merazoma();
            break;
        default
            // 想定外の数値が選ばれた場合はもう一度選びなおさせるようにしたい
    }

・呪文表示用のString型フィールドを用意し、「\n%s：2」のようにして呪文表示のフォーマットに追加していく

・レベルがまだ低いときに「つかえるじゅもんがない！」と表示して戦いの選択肢に戻すプログラムも欲しい

・じゅもんやアイテムを選択した後、戻る選択肢は0とし、returnすればbattleメソッドに戻れる

    if (this.level > 2) {
        system.out.println("つかえるじゅもんがない！")
        return;
    }
    if (this.level > 2 && this.level < 5) {
        System.out.println("ホイミ：1")
    }
    if (this.level > 5 && this.level < 9) {
        System.out.println("ホイミ：1\nメラ：2)
    }

・上記のようなプログラムだと、「じゅもん」を選択したときにいちいち計算を行わなければならない。
　その都度計算してそれに対応する物を表示するのではなく、もう用意してあるものをポンと表示したい。
　そうするにはフィールドでフォーマットを持つのが一番良いと思うが、それの上手い扱い方が分からない。
　レベルに応じてフォーマットにどうやって追加していけばよいのか？
　一番想像がつくのはcheckSpellUpに合わせて呪文一覧のフォーマットにも追加していくといった形。

・呪文一覧のフォーマットをレベルごとに合わせて表示するのは恐らく解決したが、
　このままのswitch文でいくとじゅもんをまだ1つしか習得していないのに4を入力すると
　メラミが使えてしまうプログラムになっている
　これを直すにはどうすればよいか？switch文の中でif文やcheckSpellUpの何らかの要素を使って
　判定することはできないか？
　　→　各呪文メソッド内でレベルチェックを行うようにする

・Spellメソッドの中でthis.spell.healSpell.hoimi()のようにはできない、
　なぜならSpell spell = new healSpell();を勇者クラスで行わなければならないから。
　これはmainメソッドで行う予定だが、ではspellメソッドはどうすればよいのか？

・習得したタイミングでそのじゅもんインスタンスをうみだせばよいのでは？
　しかしホイミを習得 → HealSpellインスタンスを生み出すと
　何らかの手違いでベホイミが使えてしまうのではないか？

・敵をランダムにわかせる方法とは？
　そのマップに出現する敵の種類の数だけ乱数を作成して(3種類なら「1～3」を乱数プログラムで作成)
　その値によって出現する敵を変える(1ならスライム、2ならゴブリン…みたいな感じ)
　これを勇者クラスのsearchEnemyでやるのは割と理にかなっているのでは？結構いいかも
　一瞬マップ間で敵の種類数が異なる場合どこで差異をつけるんだ？と思ったが、
　if文の中に乱数生成プログラムがあるなら全く問題なかった

・それぞれのマップに出現する通常敵の数は

　森　→　3種類
　海　→　4種類
　山　→　6種類

　にする

・上記は敵を探すときのプログラムだが、お宝を探すsearchTreasureでも同じように
　マップ属性を使えばいいかんじになるのでは？

・敵アイデア

　森
　　スライム、ウルフ、キラービー
　海
　　ひとくいザメ、かいぞく、
　山
　　デスイーグル、がんせきまじん、マグマゴーレム、

・たとえば、その地のお宝を1つ以上見つけ、敵を4体以上倒せばボス解放。
　ボスフラグを勇者クラスのフィールドに定義する。
　chooseMapActionメソッド内のswitch文にはあらかじめcase 5:も定義しておき、
　そこに記述される仮にbattleBoss()メソッドの先で以下のプログラムを書いておけばよいのではないか？

　if (ボスフラグ == off) {
    return;
} else if (ボスフラグ == on) {
    chooseMapActionで表示する文字列変数 += "ボスとたたかう：5"
}

・マップ間の移動がマップアクションで選べるならば、各マップでボスフラグの進行状況は違う
　仮に森：4(ボス出現)　海：3(ボス未出現)　山：7(ボス出現)だとすると
　森にいる場合は5：ボスバトルが表示され、
　海にいる場合はまだ表示されず、
　山にいる場合は5：ボスバトルが表示される。

　森　　　海　　　山
　this.mapAttributeには現在いるマップ名が格納されている。
　this.forestBossFlagにはボスバトル解放のための行動回数がカウントされている。
　「今いるマップ」のボスフラグをカウントする形にもっていければよい？
　そのマップに初めて訪れる時にそのマップのインスタンスを生成するのはどうか？
　勇者が持つMapフィールドに現在いるMapインスタンスをセットすれば現在いるマップが分かる？
　this.map = new Forest();

　マップクラスはフィールドにEnemyクラスを持てると思うのだがそれはどうか？
　map.enemy = new Slime();

　マップクラスに乱数によってランダムに敵を生成するメソッドを実装するのはどうか？
　そうすれば勇者クラスのsearchEnemyメソッドがもうちょっと見やすくなるのでは？
　public Enemy createEnemy() {
    int enemyNumber = new java.util.Random().nextInt(3);
    switch(enemyNumber) {
        case 0:
            Enemy = new Slime();
            break;
    }
}

switch(this.map.getName) {
    case "森":
        Enemy enemy = this.map.createEnemy;
}

・勇者クラスのmapを現在地にするならば、つまりthis.map.createEnemy()はその現在地の敵を作ることになる？
　ということはsearchEnemyでマップによってswitch文で振り分ける必要がなくなる？
　　→ 結構いい感じにいけそう

・createSpellNameList(呪文名リスト)とcreateGetSpellLevelList(呪文習得レベルリスト)の2つは
　どうにかマップにまとめていい感じにプログラムを簡単にできないか？

・そのマップをクリアしたらマップ名は「森(クリア！)」のようにしたい
　そのため、勇者クラスのthis.map.nameを用いて判別するようなプログラムは
　その変数の名前.equals("森")などにするのではなく、"森"が含まれているかどうかで判別するようにしたい。

・敵の攻撃をどうやって実装すればよいか？勇者クラスでbattleメソッドを実装しているが、
　そうするとe.attack()の引数に勇者インスタンスを持ってこれない
　battleクラスを作るのもアリ、「戦い」は勇者だけのものではなく客観的に見て
　勇者と敵の戦いなのでクラスとして独立していてもおかしくはない、はず
　しかし結局勇者インスタンスの引数をどうすればよいかは解決していない

・勇者クラスは今のところ攻撃力と守備力のみだが、これは自身のステータス + 装備合わせた数値であって
　勇者自身のステータス用の攻撃力(ちから)と守備力(みのまもり)も必要では？
　　→ 追加済み

・chooseMapActionのwhileが終わりを迎える条件は「全てのマップのボスを倒したら」になる。
　3つのマップのボス勝利状況を把握するにはどうすればよいか？

・敵の行動は引数なしのe.turn()で実装して、ダメージだけ戻り値にして
　その戻り値を勇者クラス側で計算すればよいのでは？
　敵が自身を回復する行動にした場合は戻り値をマイナスにして勇者側では何もしないようにする。
　これなら勇者クラスで全て行えるのではないか？

　damage = e.turn();
　this.hp -= damage;
　if (damage < 0) {
    return;     // 敵が自身のHPを回復するかもしれないので、負の値が返ってきたら敵の回復を意味する
}

・上記のような形で、回復呪文と攻撃呪文の使い分けもできそうな気がする
　呪文メソッドは戻り値を回復値とダメージ値にしてspellフィールドにattackSpellが入ってるなら敵にダメージ、
　healSpellが入ってるなら自分のHPを回復、のように分岐させることができるかもしれない
　それか単純に今のswitch文で　this.hp += healSpell.hoimi();　のような形でもいいかもしれない

・勇者と敵のHPを常に把握するようなプログラムはどうすればよいか？今のままだと
　「どちらかのHPが0になったら」の判定をメソッドの最初で行っているので、
　ターンの先攻でどちらかのHPが0になってもそれを検知するプログラムがまだ実装されていない。
　　→　勇者ターン(switch文)と敵ターン(e.turn)の間にifプログラムを入れる形で実装する。

・呪文メソッドで
　1．レベルのチェック
　2．ランダムにダメージや回復量を生成する
　は共通しているので、これをSpellクラスに実装して各Spellクラスで利用すれば見やすくなるのでは？
　　→　静的メソッド内でsuperを使えないため、各Spellクラス内にこのメソッドを置くようにした

・ラスボス戦の仕様をどうするか、ラスボスマップに行って「ラスボスと戦う」選択肢を出すのは少し違う気がする
　3つのマップのボスを倒すと「まおうのしろ」が解禁され、そこを選択すると
　「さいごのたたかいがはじまります。とちゅうでもどることはできません。」
　「さいごのたたかいにむかいますか？」みたいなテキストを表示させて、
　まおうのしろに行くとラスボスの刺客 → ラスボスの連戦が始まる、というのはどうか

・3つ目のマップのボスを倒せばchooseMapActionの5番選択肢がそのマップのボス戦 → ラスボス戦
　になるだけだが、1つ目、2つ目のマップではどうするか？そのマップにおいては一旦削除する処理も入れなければ
　削除する処理をデフォルトにしてその前にif (ラスボスフラグ == on)などを入れて判定する？

・お宝探しは、最初の1,2回はやくそうなどのアイテムをリスクなしで手に入れることができ、
　その後の1回は強い装備を手に入れることができる。しかし3回目の宝探しに行こうとすると
　「じゃあくなけはいをかんじる。さきにすすみますか？」のようなテキストを表示し、
　進む場合は中ボスぐらいの強さの敵と戦わせて勝てばお宝がもらえるようにする。
　進まない場合はまたchooseMapActionに戻る。

・今のところMapクラスに敵カウントやら宝フラグ、ボスフラグをフィールドとして持たせているが、
　これはマップ間を自由に移動できる場合、マップ選択のメソッドが呼び出されるたびに
　this.map = new Forest();のようになってしまっているので
　今のままではマップを選択するたびにフィールドが初期化されてしまうのでは？
　マップも自由に行き来できるのではなく、森 → 海 → 山 の流れでプレイさせるのが無難か
　しかしそうしても今のままだと初期化されていろいろおかしい点が出てきてしまう。
　インスタンス間で共有できる変数が無かったか？それを使えばよいかもしれない
　　→ 各マップにstaticで実装

・this.map.getBossFlagやthis.map.bossFlagが上手く機能しないため、
　this.map → this.forestなどのようにする必要がある

・static変数の内容を変えようとすると勇者クラスもstaticメソッドにしなければならなくなる

・Mapクラスに3つのマップのカウントを持っても上記が問題となる

・// 攻撃のダメージは自身の攻撃力～自身の攻撃力 + 2 の範囲内からランダム
// だけど攻撃力が高ければ高いほどその範囲も大きくしたい
// 最大値が最低値の倍以上になったらそれはやりすぎなのでそこでセーブしたい
// 攻撃力が2 → 2～4ぐらい　振れ幅は 2
// 攻撃力が30 → 30～38ぐらい　振れ幅は 8
// 攻撃力が4上がるごとにrangeに +1 されるような公式
// this.attack % 4 = 0 なら range = 1;
// this.attack % 4 = 1 なら rangeに +1
// つまり最終的なrangeは (this.attack % 4) + range で表せる？

・敵が逃げるかどうかの判断は、自身と勇者のレベルを比較し、勇者の方が高ければ高いほど
　逃げる確率は高くしたい。なのでe.turn()の最初にはまずそれを比較して
　逃げる確率まで算出するプログラムを挟みたい、そのプログラムはEnemyクラスに実装する

・勇者のレベルが自身と同じまでは逃げる確率 = 0にしたい
　例えばスライムならレベルが2なので勇者のレベルが1、2なら絶対に逃げない
　勇者のレベルが3なら5%ぐらいの確率で逃げたい　レベル差 = 1　確率は　5　アップ
　勇者のレベルが10なら40%ぐらいの確率で逃げたい　レベル差 = 8　確率は　40　アップ
　勇者のレベルが15なら80%ぐらいの確率で逃げたい　レベル差 = 13　確率は　80　アップ
　つまりレベル差が1つあるごとに逃げる確率を5%アップすればよい？
　これを式にすると　braveLevel - this.level = levelGap(levelGapが0以下なら逃げない)
　逃げる確率 = levelGap * 5;
　　→　これに加え、範囲が100の中から乱数を生成し、その乱数がlevelGapの数以下なら逃げる、
　　　　levelGapの数より大きいなら逃げない、といった処理にした。

・スライムの行動に「スライムはぷるぷるとうごいている」を追加し、この行動の場合勇者にダメージは入らないので
　メソッドの戻り値は-1にしたい。他にも勇者にダメージを与えない敵の特殊な行動は負の値を返すようにしたい
　(負の値ならif(戻り値 < 0)で勇者にダメージが入るかどうかの判定ができるし
　特殊な行動が複数あった場合に-2,-3…と増やしていけるから)
　そうすると、逃げるフラグは0になる、しかしenemyAttack - braveDefenseなどの計算で
　勇者の防御力が敵の攻撃力を上回った場合にも戻り値は0になってしまうため、
　この2つの0をどうやって判別するのかが問題
　EnemyクラスのbattleFlagを使えばよいのでは？というかそのために作ったような
　しかし攻撃前にbattleFlagを読み取って逃げるかの判定を行うのが難しい、どこで判定すればよいのか？
　逃げるかどうかの判定はe.turnに組み込まず、brave側で判定すればよいのでは？

・敵が逃げた場合経験値は取得できないようにしたいが、
　勇者のHPが0になったのか、敵のHPが0になったのか
　敵が逃げたのか
　それらがターンの中間に行われたのかターンの終了に行われたのか
　ということはbattleメソッドの最後にif(this.hp <= 0) else {} などの処理を行うのではなく、
　勇者ターンで勇者が死ぬこと、敵ターンで敵が死ぬことはまずありえないので
　勇者ターンの終わりには敵HPの判定を、敵ターンの終わりには勇者HPの判定を行えばよいのでは？

・戦いの選択肢でたとえば「じゅもん」→「やっぱりやめる」のような流れは
　switch文の中でcontinueを使えば実現できそうか？

・「ぼうぎょ」を選択した場合に、強制的に勇者は先攻となりそのターンが終わるまで防御力を増やす、
　または、先攻か後攻かは変わらず素早さで判断し、もし先攻ならそのターン終わりまで防御力を増やせばよい、
　もし後攻なら次のターンも強制的に勇者を後攻にし、その前の敵のターンは防御力を増やす
　という風に分けられるか？こういった場合の処理に対して勇者自身の経過ターン数を表す
　フィールドがあると便利、経過ターン数が+1されたらぼうぎょを解除するなど

・攻撃にも3種類ある、ミス、通常攻撃、会心の攻撃　同じく敵にもこれがある。
　これも考慮しなければならない。

・breakはそのメソッドの全てのループを抜ける、continueは今いるスコープのループを抜ける。
　このため、現段階でbattleメソッドでswitch文(勇者ターン)の処理が終わった時に
　一番大元のwhile文に行く方法がラベルしかない。しかしラベルはあまり使いたくない。

　てっきりcontinueは今いるスコープのループだけ終わらせるのかと思っていたが尚continueがどういう挙動なのかが
　わからなくなってしまった。同様にbreakも試してみたらまさかのbreakでも同じような実行結果となったので
　breakとcontinueがわからなくなってしまった。どういうこと？
　とりあえずどっちも今いるループは抜けて、大元のループに帰ってくれるらしい

        int a = 1;
        int b = 1;
        int i = 0;
        while(i < 3) {
            System.out.println("while--start");
            if (b == 1) {
                System.out.println("if--start");
                switch(a) {
                    case 1:
                        System.out.println("switch");
                        i++;
                        continue;　←　ここに注目
                }
                System.out.println("if--end");
            }
            System.out.println("while--end");
        }
        System.out.println("全てのループが終了");

　上記のコードの実行結果は以下の通り。

        while--start
        if--start
        switch
        while--start
        if--start
        switch
        while--start
        if--start
        switch
        全てのループが終了

　if--endとwhile--endが処理されていない。
　そして、continueをbreakに変えたときの実行結果が以下の通り。

        while--start
        if--start
        switch
        if--end
        while--end
        while--start
        if--start
        switch
        if--end
        while--end
        while--start
        if--start
        switch
        if--end
        while--end
        全てのループが終了

　continueでは実行されなかったif--endとwhile--endが実行されている。
　ここからわかることは、continueを用いると、その時点でその周回を終了し、
　大元のループからやり直す。
　breakを用いると、とりあえず今いるループだけを終わらせて残っている元の周回の処理をしつつ
　また大元のループからやり直す、といった挙動の違いになる。

・勇者か敵のHPが0になったらバトルを終了させるためにbreakを配置していたが、
　上記から大元のループに戻ってしまうことがわかったため、大元のwhile文の条件式を
　勇者HPと敵HPの判定 → 勇者か敵どちらかが死んだらの判定にした方が良さげ
　b.win()とb.die()でboolean型の変数か何かを変更し、
　それで判定するのが良さげ
　　→ 条件式を　while (!this.battleWin || !this.battleLose)　として、
　　　win()とdie()内でそれぞれのフラグをtrueに設定するようにした。


・[進捗]各Mapのsetterを使用してどうにかマップの敵キル数や宝入手状況、ボスフラグを保存できないか
　　　　Slimeのe.turn()の実装
　　　　attackのミスや会心の一撃の実装
　　　　defense()について経過ターン数を用いた判定の実装

=========================================================================================================

ゲームのフロー

どのマップに行きますか？(mapChoose) → 選ばせる(return)
↓
選んだ数字に該当するマップを決める(仮に森だとする) → 選んだ答えによって決める(chooseMap,switch文？)
↓
森にやってきた！ → 表示する(system.out.println)
↓
勇者はどうする？(mapAction,while) → 選ばせる(return)
↓
選択肢によって行動が変わる(仮にsearchEnemyとする) → 選んだ答えによって決める(switch → battle)
↓
敵と戦う(Battle) → Battleの中で行動を選ばせる(while内でswitch) → 敵か勇者のHPが0になったら繰り返し終了
↓
戦いが終わる
↓
勇者はどうする？(mapAction,while)
↓
一定の条件をクリアするとマップの奥地(ボス戦)が解放される
↓
勇者はどうする？(mapActionにボス戦が追加されたやつ)
↓
ボス戦を選択
↓
ボスイベント(Forest.bossEvent)
↓
ボスを倒した！
↓
どのマップに行きますか？(mapChoose)

=========================================================================================================

呪文使用のフロー

「じゅもん」を選択(battle)
↓
呪文一覧を番号に対応させた形で表示(printf)
↓
呪文を選択
↓
選択された呪文によって呼び出すメソッドを変える(switch)
↓
その呪文インスタンスを

=========================================================================================================

ボス戦解放のフロー　※仮にその地の敵を4体、宝物(装備)を1つ見つけたら解放とする

敵を倒す(そのマップの倒した敵カウント+1)
↓
敵を倒す(同上)
↓
宝物(装備)を見つける(そのマップの宝物フラグ = true)
↓
敵を倒す(同上)
↓
敵を倒す(同上)
↓
ここで敵を4体、宝を1つ見つけたのでそのマップのボスフラグがONになりボス戦が解放される
(enemyCount == 4, treasureFlag == true, Map.bossFlag = true)
↓
ボス戦が終わればそのマップのボスフラグをfalseにし、
ラスボスフラグ(int?)に+1する。もしこのマップのボスを倒したことでラスボスフラグが
3になったのならchooseMapActionの5番をマップボス戦 → ラスボス戦に入れ替える。
そうでない場合、5番の選択肢をそのマップにおいてのみ削除する。

=========================================================================================================

ミスや引っかかったこと、つまずいたことやわからないこと

・import map;としてもimport文にエラーが出現し、mapパッケージのファイルが読みこめない。
　import map.Mapやimport spell.Spellだとちゃんと認識してくれる。
　だけどいちいちattackspellやhealspellとかもimportで記述しないといけないのは面倒。
　　→ そもそもimport文は「import パッケージ名.クラス名」のようにクラス名まで記述する必要があるため、
　　　import map;のように「import クラス名;」でエラーが出るのは当然。単に基礎知識不足だった。
　　　「import Map.*」や「import spell.*」とすることによって解決。

・