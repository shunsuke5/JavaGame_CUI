javaゲーム メモ

・文章が表示される間隔を2秒ぐらいにしたい
　(欲を言えばクリックするごとに表示させたい)

・フィールドで勇者のaction()メソッドを呼び出す感じにする。
　action()メソッドは、どのアクションを行いますか？と表示し
　討伐、探索、休む、マップ移動などを選択肢で表示する。

・while (イベントカウント) {
    action();
    
}

・各フィールドのクリア条件は、討伐と探索を決められた回数クリアしたらにする
　決められた回数クリアしたら強制的にイベントに進ませるのではなく、
　mapActionに「ボス戦」の選択肢を追加する
　「(マップの奥地が解放された！十分な準備をしてからここに進もう」などのテキスト)

・3つあるフィールドはそれぞれ微妙に難易度が違うようにするのか、
　それとも同じようにするのか。

・探索はお宝を得られるチャンスのため、リスクがあった方がおもしろいのでは？
　中ボスを配置するなど

・どうのつるぎ、はがねのつるぎなどはmainプログラムの方で生み出す感じとなる。

・ターン制バトルをどうやって実現する？

・while(勇者のHPが0になるか、敵のHPが0になるか、どちらかが逃げるか) {
    battle();
}

・勇者の最大HPはどのように定義すればよいのか？ → 勇者クラスに専用の変数を定義
　レベルアップの時だけこの変数を呼び出すようにする。

・じゅもんを選択したがやはり違うことをしたいなどといったときに、
　もどれるプログラムもほしい

・レベル上限は20とする

・[進捗]battle()メソッドに渡す敵の引数について、マップごとに敵情報を変えて渡すにはどうすればよいか？
　　　　

・敵を倒した時に1体の敵を倒したときと複数の敵を倒した時の挙動を変えるには？？
　そもそもbattle()メソッドに複数の敵インスタンスを渡したい時にはどうすればよいのか？
　敵の数という情報は配列の形にした方が良い？
　それならbattle(Enemy[] e) とすればその配列の中身が単体でも複数でも想定しているプログラムになるはず
　「e[0].name + "と" e[1].nameをたおした！」のような記述になる
　ただ問題点が1つ、同じモンスターを複数倒した場合に「スライムとスライムをたおした！」ではおかしいので
　equals()のようなメソッドを用いて渡された配列内のモンスター名を等価か判断する必要が出てくる。

    if (配列内のモンスター名が重複していない場合){
        System.out.println(e[0].name + "と" + e[1].name + "をたおした！");
    } else {
        System.out.println(e[0].name + "をたおした！");
    }

　なお、上記のプログラムは2体を想定しているので数が増えればもっと複雑になる
　まあ簡単なゲームなので敵の最大数は3体でもいいし、このゲームはドラクエ1ライクのつもりなので
　なんなら敵は全て単体でもよい

　ちなみにもしこのプログラムを利用するならば、敵が生成される時に配列に入れる順番は
　名前を辞書順で入れると同じモンスターは必ずインデックスが連番で入るので
　それを利用して重複を確かめることにすると楽になるかも

・levelList.addももうちょい見やすく短い方法で記述できたら良い
　for文で決まった数だけ上乗せしていって周回数が一定の回数になったら
　さらに必要経験値を上乗せしていくなど
　この形のようにレベルが上がれば上がるほど必要経験値も上がっていく
　"比例"のようなプログラムを作るにはどうしたらよいのか？
　y(必要経験値) = ( 〇(現在のレベル) * x(定数) )
　上記のような形でいけるか？今回は以下の式を採用

    while (int i < 21;) {
        levelList.add(levelPoint)
        levelPoint = (int)( (levelPoint + this.level) * 1.25);
        i++
    }

・Spell healSpell = new HealSpell();
　Spell attackSpell = new AttackSpell();
　で勇者が持つ呪文インスタンスを2種類に分けて生み出し、使う時は
　brave.healSpell.hoimi();　のようにして呼び出す。

・仮に呪文の上限が5個だとして、(ホイミ(3)、メラ(5)、ベホイミ(9)、メラミ(14)、メラゾーマ(17))
　呪文一覧を表示する際にレベルアップの状況に応じてその時点で習得している呪文を表示するには？
　レベルアップのメソッドに呪文を紐づける必要がある。そして、勇者クラスに呪文一覧表示のフォーマットを
　作成し、レベルアップのときに呪文を表示するフォーマットに習得した呪文を増やすプログラムを書く必要がある。

・経験値とレベルはマップにして対応表みたいな形で扱えばよいのでは？(むずそうなので保留)

・呪文に番号を振る形に決定する。

    switch(spellChoice) {
        case 1:
            healSpell.hoimi();
            break;
        case 2:
            attackSpell.mera();
            break;
        case 3:
            healSpell.behoimi();
            break;
        case 4:
            attackSpell.merami();
            break;
        case 5:
            attackSpell.merazoma();
            break;
        default
            // 想定外の数値が選ばれた場合はもう一度選びなおさせるようにしたい
    }

・呪文表示用のString型フィールドを用意し、「\n%s：2」のようにして呪文表示のフォーマットに追加していく

・レベルがまだ低いときに「つかえるじゅもんがない！」と表示して戦いの選択肢に戻すプログラムも欲しい

・じゅもんやアイテムを選択した後、戻る選択肢は0とし、returnすればbattleメソッドに戻れる

    if (this.level > 2) {
        system.out.println("つかえるじゅもんがない！")
        return;
    }
    if (this.level > 2 && this.level < 5) {
        System.out.println("ホイミ：1")
    }
    if (this.level > 5 && this.level < 9) {
        System.out.println("ホイミ：1\nメラ：2)
    }

・上記のようなプログラムだと、「じゅもん」を選択したときにいちいち計算を行わなければならない。
　その都度計算してそれに対応する物を表示するのではなく、もう用意してあるものをポンと表示したい。
　そうするにはフィールドでフォーマットを持つのが一番良いと思うが、それの上手い扱い方が分からない。
　レベルに応じてフォーマットにどうやって追加していけばよいのか？
　一番想像がつくのはcheckSpellUpに合わせて呪文一覧のフォーマットにも追加していくといった形。

・呪文一覧のフォーマットをレベルごとに合わせて表示するのは恐らく解決したが、
　このままのswitch文でいくとじゅもんをまだ1つしか習得していないのに4を入力すると
　メラミが使えてしまうプログラムになっている
　これを直すにはどうすればよいか？switch文の中でif文やcheckSpellUpの何らかの要素を使って
　判定することはできないか？
　　→　各呪文メソッド内でレベルチェックを行うようにする

・Spellメソッドの中でthis.spell.healSpell.hoimi()のようにはできない、
　なぜならSpell spell = new healSpell();を勇者クラスで行わなければならないから。
　これはmainメソッドで行う予定だが、ではspellメソッドはどうすればよいのか？

・習得したタイミングでそのじゅもんインスタンスをうみだせばよいのでは？
　しかしホイミを習得 → HealSpellインスタンスを生み出すと
　何らかの手違いでベホイミが使えてしまうのではないか？

・敵をランダムにわかせる方法とは？
　そのマップに出現する敵の種類の数だけ乱数を作成して(3種類なら「1～3」を乱数プログラムで作成)
　その値によって出現する敵を変える(1ならスライム、2ならゴブリン…みたいな感じ)
　これを勇者クラスのsearchEnemyでやるのは割と理にかなっているのでは？結構いいかも
　一瞬マップ間で敵の種類数が異なる場合どこで差異をつけるんだ？と思ったが、
　if文の中に乱数生成プログラムがあるなら全く問題なかった

・それぞれのマップに出現する通常敵の数は

　森　→　3種類
　海　→　4種類
　山　→　6種類

　にする

・上記は敵を探すときのプログラムだが、お宝を探すsearchTreasureでも同じように
　マップ属性を使えばいいかんじになるのでは？

・敵アイデア

　森
　　スライム、ウルフ、キラービー
　海
　　ひとくいザメ、かいぞく、
　山
　　デスイーグル、がんせきまじん、マグマゴーレム、

・たとえば、その地のお宝を1つ以上見つけ、敵を4体以上倒せばボス解放。
　ボスフラグを勇者クラスのフィールドに定義する。
　chooseMapActionメソッド内のswitch文にはあらかじめcase 5:も定義しておき、
　そこに記述される仮にbattleBoss()メソッドの先で以下のプログラムを書いておけばよいのではないか？

　if (ボスフラグ == off) {
    return;
} else if (ボスフラグ == on) {
    chooseMapActionで表示する文字列変数 += "ボスとたたかう：5"
}

・マップ間の移動がマップアクションで選べるならば、各マップでボスフラグの進行状況は違う
　仮に森：4(ボス出現)　海：3(ボス未出現)　山：7(ボス出現)だとすると
　森にいる場合は5：ボスバトルが表示され、
　海にいる場合はまだ表示されず、
　山にいる場合は5：ボスバトルが表示される。

　森　　　海　　　山
　this.mapAttributeには現在いるマップ名が格納されている。
　this.forestBossFlagにはボスバトル解放のための行動回数がカウントされている。
　「今いるマップ」のボスフラグをカウントする形にもっていければよい？
　そのマップに初めて訪れる時にそのマップのインスタンスを生成するのはどうか？
　勇者が持つMapフィールドに現在いるMapインスタンスをセットすれば現在いるマップが分かる？
　this.map = new Forest();

　マップクラスはフィールドにEnemyクラスを持てると思うのだがそれはどうか？
　map.enemy = new Slime();

　マップクラスに乱数によってランダムに敵を生成するメソッドを実装するのはどうか？
　そうすれば勇者クラスのsearchEnemyメソッドがもうちょっと見やすくなるのでは？
　public Enemy createEnemy() {
    int enemyNumber = new java.util.Random().nextInt(3);
    switch(enemyNumber) {
        case 0:
            Enemy = new Slime();
            break;
    }
}

switch(this.map.getName) {
    case "森":
        Enemy enemy = this.map.createEnemy;
}

・勇者クラスのmapを現在地にするならば、つまりthis.map.createEnemy()はその現在地の敵を作ることになる？
　ということはsearchEnemyでマップによってswitch文で振り分ける必要がなくなる？
　　→ 結構いい感じにいけそう

・createSpellNameList(呪文名リスト)とcreateGetSpellLevelList(呪文習得レベルリスト)の2つは
　どうにかマップにまとめていい感じにプログラムを簡単にできないか？

・そのマップをクリアしたらマップ名は「森(クリア！)」のようにしたい
　そのため、勇者クラスのthis.map.nameを用いて判別するようなプログラムは
　その変数の名前.equals("森")などにするのではなく、"森"が含まれているかどうかで判別するようにしたい。

・敵の攻撃をどうやって実装すればよいか？勇者クラスでbattleメソッドを実装しているが、
　そうするとe.attack()の引数に勇者インスタンスを持ってこれない
　battleクラスを作るのもアリ、「戦い」は勇者だけのものではなく客観的に見て
　勇者と敵の戦いなのでクラスとして独立していてもおかしくはない、はず
　しかし結局勇者インスタンスの引数をどうすればよいかは解決していない

・勇者クラスは今のところ攻撃力と守備力のみだが、これは自身のステータス + 装備合わせた数値であって
　勇者自身のステータス用の攻撃力(ちから)と守備力(みのまもり)も必要では？
　　→ 追加済み

・chooseMapActionのwhileが終わりを迎える条件は「全てのマップのボスを倒したら」になる。
　3つのマップのボス勝利状況を把握するにはどうすればよいか？

・敵の行動は引数なしのe.turn()で実装して、ダメージだけ戻り値にして
　その戻り値を勇者クラス側で計算すればよいのでは？
　敵が自身を回復する行動にした場合は戻り値をマイナスにして勇者側では何もしないようにする。
　これなら勇者クラスで全て行えるのではないか？

　damage = e.turn();
　this.hp -= damage;
　if (damage < 0) {
    return;     // 敵が自身のHPを回復するかもしれないので、負の値が返ってきたら敵の回復を意味する
}

・上記のような形で、回復呪文と攻撃呪文の使い分けもできそうな気がする
　呪文メソッドは戻り値を回復値とダメージ値にしてspellフィールドにattackSpellが入ってるなら敵にダメージ、
　healSpellが入ってるなら自分のHPを回復、のように分岐させることができるかもしれない
　それか単純に今のswitch文で　this.hp += healSpell.hoimi();　のような形でもいいかもしれない

・勇者と敵のHPを常に把握するようなプログラムはどうすればよいか？今のままだと
　「どちらかのHPが0になったら」の判定をメソッドの最初で行っているので、
　ターンの先攻でどちらかのHPが0になってもそれを検知するプログラムがまだ実装されていない。
　　→　勇者ターン(switch文)と敵ターン(e.turn)の間にifプログラムを入れる形で実装する。

・呪文メソッドで
　1．レベルのチェック
　2．ランダムにダメージや回復量を生成する
　は共通しているので、これをSpellクラスに実装して各Spellクラスで利用すれば見やすくなるのでは？
　　→　静的メソッド内でsuperを使えないため、各Spellクラス内にこのメソッドを置くようにした

・ラスボス戦の仕様をどうするか、ラスボスマップに行って「ラスボスと戦う」選択肢を出すのは少し違う気がする
　3つのマップのボスを倒すと「まおうのしろ」が解禁され、そこを選択すると
　「さいごのたたかいがはじまります。とちゅうでもどることはできません。」
　「さいごのたたかいにむかいますか？」みたいなテキストを表示させて、
　まおうのしろに行くとラスボスの刺客 → ラスボスの連戦が始まる、というのはどうか

・3つ目のマップのボスを倒せばchooseMapActionの5番選択肢がそのマップのボス戦 → ラスボス戦
　になるだけだが、1つ目、2つ目のマップではどうするか？そのマップにおいては一旦削除する処理も入れなければ
　削除する処理をデフォルトにしてその前にif (ラスボスフラグ == on)などを入れて判定する？

・お宝探しは、最初の1,2回はやくそうなどのアイテムをリスクなしで手に入れることができ、
　その後の1回は強い装備を手に入れることができる。しかし3回目の宝探しに行こうとすると
　「じゃあくなけはいをかんじる。さきにすすみますか？」のようなテキストを表示し、
　進む場合は中ボスぐらいの強さの敵と戦わせて勝てばお宝がもらえるようにする。
　進まない場合はまたchooseMapActionに戻る。

・今のところMapクラスに敵カウントやら宝フラグ、ボスフラグをフィールドとして持たせているが、
　これはマップ間を自由に移動できる場合、マップ選択のメソッドが呼び出されるたびに
　this.map = new Forest();のようになってしまっているので
　今のままではマップを選択するたびにフィールドが初期化されてしまうのでは？
　マップも自由に行き来できるのではなく、森 → 海 → 山 の流れでプレイさせるのが無難か
　しかしそうしても今のままだと初期化されていろいろおかしい点が出てきてしまう。
　インスタンス間で共有できる変数が無かったか？それを使えばよいかもしれない
　　→ 各マップにstaticで実装

・this.map.getBossFlagやthis.map.bossFlagが上手く機能しないため、
　this.map → this.forestなどのようにする必要がある

・static変数の内容を変えようとすると勇者クラスもstaticメソッドにしなければならなくなる

・Mapクラスに3つのマップのカウントを持っても上記が問題となる

・// 攻撃のダメージは自身の攻撃力～自身の攻撃力 + 2 の範囲内からランダム
// だけど攻撃力が高ければ高いほどその範囲も大きくしたい
// 最大値が最低値の倍以上になったらそれはやりすぎなのでそこでセーブしたい
// 攻撃力が2 → 2～4ぐらい　振れ幅は 2
// 攻撃力が30 → 30～38ぐらい　振れ幅は 8
// 攻撃力が4上がるごとにrangeに +1 されるような公式
// this.attack % 4 = 0 なら range = 1;
// this.attack % 4 = 1 なら rangeに +1
// つまり最終的なrangeは (this.attack % 4) + range で表せる？

・敵が逃げるかどうかの判断は、自身と勇者のレベルを比較し、勇者の方が高ければ高いほど
　逃げる確率は高くしたい。なのでe.turn()の最初にはまずそれを比較して
　逃げる確率まで算出するプログラムを挟みたい、そのプログラムはEnemyクラスに実装する
　
　勇者のレベルが自身と同じまでは逃げる確率 = 0にしたい
　例えばスライムならレベルが2なので勇者のレベルが1、2なら絶対に逃げない
　勇者のレベルが3なら5%ぐらいの確率で逃げたい　レベル差 = 1　確率は　5　アップ
　勇者のレベルが10なら40%ぐらいの確率で逃げたい　レベル差 = 8　確率は　40　アップ
　勇者のレベルが15なら80%ぐらいの確率で逃げたい　レベル差 = 13　確率は　80　アップ
　つまりレベル差が1つあるごとに逃げる確率を5%アップすればよい？
　これを式にすると　braveLevel - this.level = levelGap(levelGapが0以下なら逃げない)
　逃げる確率 = levelGap * 5;
　　→　これに加え、範囲が100の中から乱数を生成し、その乱数がlevelGapの数以下なら逃げる、
　　　　levelGapの数より大きいなら逃げない、といった処理にした。

・スライムの行動に「スライムはぷるぷるとうごいている」を追加し、この行動の場合勇者にダメージは入らないので
　メソッドの戻り値は-1にしたい。他にも勇者にダメージを与えない敵の特殊な行動は負の値を返すようにしたい
　(負の値ならif(戻り値 < 0)で勇者にダメージが入るかどうかの判定ができるし
　特殊な行動が複数あった場合に-2,-3…と増やしていけるから)
　そうすると、逃げるフラグは0になる、しかしenemyAttack - braveDefenseなどの計算で
　勇者の防御力が敵の攻撃力を上回った場合にも戻り値は0になってしまうため、
　この2つの0をどうやって判別するのかが問題
　EnemyクラスのbattleFlagを使えばよいのでは？というかそのために作ったような
　しかし攻撃前にbattleFlagを読み取って逃げるかの判定を行うのが難しい、どこで判定すればよいのか？
　逃げるかどうかの判定はe.turnに組み込まず、brave側で判定すればよいのでは？
　　→ 敵が逃げるかの判定はe.turn()内で行わず、brave側でe.runJadgement()を呼び出すことにした。
　　　そして勇者にダメージが入らない特殊な行動についてテキストの表示や
　　　特殊なステータスの計算は敵側の行動メソッドで処理を行い、
　　　勇者側にはダメージが無いことだけ伝えることにした(return 0;)
　　　勇者の防御力が敵の攻撃力を上回った場合、0ポイントのダメージ！のように表示されてしまうが、
　　　単なるミスと区別が付けられるのでこれはこれでよいかなと思った。

・敵が逃げた場合経験値は取得できないようにしたいが、
　勇者のHPが0になったのか、敵のHPが0になったのか
　敵が逃げたのか
　それらがターンの中間に行われたのかターンの終了に行われたのか
　ということはbattleメソッドの最後にif(this.hp <= 0) else {} などの処理を行うのではなく、
　勇者ターンで勇者が死ぬこと、敵ターンで敵が死ぬことはまずありえないので
　勇者ターンの終わりには敵HPの判定を、敵ターンの終わりには勇者HPの判定を行えばよいのでは？
　　→ 実装済み

・戦いの選択肢でたとえば「じゅもん」→「やっぱりやめる」のような流れは
　switch文の中でcontinueを使えば実現できそうか？
　　→ breakだと残った処理もしてしまうので、勇者が先攻だった場合残りの敵ターンも実行してしまう。
　　　よってcontinueで対応

・「ぼうぎょ」を選択した場合に、強制的に勇者は先攻となりそのターンが終わるまで防御力を増やす、
　または、先攻か後攻かは変わらず素早さで判断し、もし先攻ならそのターン終わりまで防御力を増やせばよい、
　もし後攻なら次のターンも強制的に勇者を後攻にし、その前の敵のターンは防御力を増やす
　という風に分けられるか？こういった場合の処理に対して勇者自身の経過ターン数を表す
　フィールドがあると便利、経過ターン数が+1されたらぼうぎょを解除するなど

・breakはそのメソッドの全てのループを抜ける、continueは今いるスコープのループを抜ける。
　このため、現段階でbattleメソッドでswitch文(勇者ターン)の処理が終わった時に
　一番大元のwhile文に行く方法がラベルしかない。しかしラベルはあまり使いたくない。

　てっきりcontinueは今いるスコープのループだけ終わらせるのかと思っていたが尚continueがどういう挙動なのかが
　わからなくなってしまった。同様にbreakも試してみたらまさかのbreakでも同じような実行結果となったので
　breakとcontinueがわからなくなってしまった。どういうこと？
　とりあえずどっちも今いるループは抜けて、大元のループに帰ってくれるらしい

        int a = 1;
        int b = 1;
        int i = 0;
        while(i < 3) {
            System.out.println("while--start");
            if (b == 1) {
                System.out.println("if--start");
                switch(a) {
                    case 1:
                        System.out.println("switch");
                        i++;
                        continue;　←　ここに注目
                }
                System.out.println("if--end");
            }
            System.out.println("while--end");
        }
        System.out.println("全てのループが終了");

　上記のコードの実行結果は以下の通り。

        while--start
        if--start
        switch
        while--start
        if--start
        switch
        while--start
        if--start
        switch
        全てのループが終了

　if--endとwhile--endが処理されていない。
　そして、continueをbreakに変えたときの実行結果が以下の通り。

        while--start
        if--start
        switch
        if--end
        while--end
        while--start
        if--start
        switch
        if--end
        while--end
        while--start
        if--start
        switch
        if--end
        while--end
        全てのループが終了

　continueでは実行されなかったif--endとwhile--endが実行されている。
　ここからわかることは、continueを用いると、その時点で大元の周回も含めて終了し、
　また大元のループからやり直す。
　breakを用いると、とりあえず今いるループだけを終わらせて残っている元の周回の処理をしつつ
　また大元のループからやり直す、といった挙動の違いになる。

・勇者か敵のHPが0になったらバトルを終了させるためにbreakを配置していたが、
　上記から大元のループに戻ってしまうことがわかったため、大元のwhile文の条件式を
　勇者HPと敵HPの判定 → 勇者か敵どちらかが死んだらの判定にした方が良さげ
　b.win()とb.die()でboolean型の変数か何かを変更し、
　それで判定するのが良さげ
　　→ 条件式を　while (!this.battleWin || !this.battleLose)　として、
　　　win()とdie()内でそれぞれのフラグをtrueに設定するようにした。

・攻撃にも3種類ある、ミス、通常攻撃、会心の攻撃　同じく敵にもこれがある。
　これも考慮しなければならない。attackは勇者と敵問わずミスと会心の一撃の確率は一緒にする
　ミスは10%、会心は5%ぐらいでいいだろうか
　　→ 上記の確率で勇者と敵のattackメソッドに実装

・this.turnCount += 1;　の処理を各メソッド(attack(),spell(),defense(),useItem())内で行うようにすれば、
　spell()とuseItem()に関してはif(入力値 == 0) {turnCountに+1せずにメソッド終了}のようにして、
　battle()の勇者ターンの最初に while(turnCount < (turnCount + 1)) とすれば
　0で戦いの選択肢に戻ってこれるのでは？
　　→ 上記の通りに実装済み

・戦いが終わる条件は4つ、勇者のHPが0、敵のHPが0、勇者が逃げる、敵が逃げる
　これをbattle()のwhile条件式に記述しなければならない
　　→ 4つの条件のフラグを勇者クラスに追加し、それで判定するwhile条件式を実装済み
　　　ターン区切りに配置されるdie()やwin()、run()の後にはcontinue;を記述
　　　(breakだと残りのループ処理が実行されてしまうため、continueなら一番最初のwhileに戻ってくれるから)

・アイテムは何を用意すればよいか？今回のゲームではHP回復とMP回復だけでよいのでは？
　(本当は状態異常を治したり付与したり、必ず逃げられるアイテムとかも用意したいが、これは余裕があれば)

・アイテムの説明表示はchooseMapActionのアイテム確認のみで行えるものとしたい
　「せつめいをひょうじしたいアイテムを選択してください」のようなテキストを表示して選ばせる
　バトル中にも表示できるようにはしたいが、ゲーム画面がごちゃごちゃしてしまいそうなので無し
　ということはじゅもんとそうびもアイテム同様、chooseMapActionで確認できるようにしたい
　これらは「自身が所持しているものの確認」といった点では同じなのでまず
　どの項目を確認する？　→　じゅもん：1　そうび：2　アイテム：3　のような形で枝分かれさせ、
　その先でもどのじゅもん、どのそうび、どのアイテムを確認するのかを選ばせて説明を表示させる。

・useYakusou() {
    Item yakusou = new HpItem(10,5);   // やくそうを作成、10～5の間で回復
    if (yakusou.count == 0) {
        return;     // やくそうの所持数が0なら使用できない
    } else {
        yakusou.use();  // 使用して体力回復
    }
}

・ただやすめるだけだとゴールドと言う概念がある意味がないので、
　宿で休むに変更してゴールドを消費するようにする
　そして、ショップを用意してアイテムを買えるようにする
　そうなってくると、「おたからをさがす」選択肢が必要かどうか疑問になってくる
　薬草などのアイテムはショップで買えるようになるし、
　つよいそうびは「そのマップのボスを倒したら手に入る」でよいのでは？
　それか、マップボスはもう最初から挑戦できるようにして(当然いきなり勝てるような相手ではないが)
　ある程度そのマップの敵を倒したら「ひきょうのちをはっけんした！」
　「おたからのけはいがする…」と表示し、秘境を解禁して
　そこの中ボスを倒したら強い装備が手に入る、みたいにしてもよいかも
　マップボスに挑戦する際、こちらが想定しているレベルに満たない場合は
　「きびしいたたかいになることがよそうされます。それでもいどみますか？」みたいな文を表示してもよい
　レベルを満たしている場合は「ほんとうにいどみますか？」だけにするなど

・アイテムはArrayListの形でもって、リストに要素があればuse()で
　リストに要素が無ければつかえない、と言った形でよいのでは？
　アイテムを手に入れる時はget()なりを用意し、リストに要素を1つ追加する。

List<String> itemList = ArrayList<String>();

public void getItem(String itemName) {
    item.add("yakusou");
}

public void checkHaveItem(Item item) {
    if (this.itemList.contains(item.getName())) {
        useItem(item);
    } else {
        System.out.println("アイテムをもっていない！");
    }
}

public void useItem(Item item) {
    
}

this.hp += yakusou.use;

ゲット時の処理
Item item = new Yakusou();
itemList.add(item);
使用時の処理
itemList.contains()
itemList.remove(item);
itemList.add(createItem("yakusou"));

・アイテムリストにはアイテム名を格納し、そのアイテムを使いたい時、
　アイテムリストの先頭から使いたいアイテム名に一致するものを探していく。
　一致した要素を使用 = リストから削除し、回復処理を行う。

・アイテムは戦闘中だけでなくマップ内アクションのアイテム確認からも使えるようにしたい
　なぜならやどやより薬草の方が安い場合、そっちで回復したいユーザーもいるだろうから

・現段階ではレベルアップ時のステータスを考えていないのでは？これも考える

・アイテム上限は各アイテム99個とする、そうしたら配列が使用できる？

・単純に考えて、アイテムを入手する状況は2つしかない。
　自分で買う時と、モンスターがドロップする時。
　買えるアイテムはレベルの進行具合、もしくはマップの進行具合によって順次増やしていきたい。
　マップクリアごとに商品入荷、など。
　これを実現したい場合、各マップ.bossKillのtrue数をカウントするプログラムが必要になる。

・果たして本当にMapクラスにボスを倒したかどうかの判定や、敵を倒した数のフィールドを実装する必要があるか？
　createEnemy()はマップごとに敵の情報が違うためマップは敵の情報を持っている=createEnemy()はMapクラスに
　実装したが、ボスを倒した、敵を倒したなどの情報は別に勇者クラスが持っていてもよいのでは？
　Mapは1つしか存在しえないのにそのマップに移動するたびにMapインスタンスが生成されなおすというのも
　おかしいとは思うが、ならばMapインスタンスを保存する方法を考えるべきか？
　勇者クラスにforestMap、seaMap、mountainMapの3つのフィールドを持って
　今いるマップはtrue、いないマップはbooleanのようにすべきか？
　各マップのフィールドにboolean there;のようなフィールドを用意して、今いるマップはそれがtrueになる、など
　そうすればchooseMapの時もif (this.forestMap == null) のようなチェックができる。
　こうすれば各マップは1つしか生成されなくなる

・そのマップの中でも弱い敵、強い敵がいるため出現確率は同じではなく弱い敵ほど出やすいようにしたい。

・マップ内アクションを表示する時など、thereIsがtrueになっているマップの情報を表示したい時
　どうすればよいか？forestMap.thereIs,seaMap.thereIs,mountain.thereIs の3つ
　この3つのどれがtrueになっているか調べ、trueになっているマップの任意の情報を取り出すには？
　if (forestMap.thereIs) { enemy = forestMap.createEnemy(); }
　敵を作るのはこれでできそうだが、問題はマップ内で一定の敵を倒したら選択肢に現れる
　「ひきょうをたんさく」について。これを表示するには
　マップの敵キルカウントを調べ、一定数以上ならテキストを追加で表示する
　if (forestMap.enemyKillCount > 5) { str += うんたらかんたら}
　プログラムが少しわかりづらくなってしまうが、今のところはこれでいいか
　というかこれの判別用メソッドを別で作って、それを呼び出す形にしたい
　3つの内のどれかのマップ.createEnemy();のようにしたいので
public Map hogehoge() {
    if (this.forestMap.thereIs) {
        return this.forestMap;
    } else if(this.seaMap.thereIs) {
        return this.seaMap;
    } else {
        return this.mountainMap;
    }
}

・マップ移動の時、移動先のマップのthereIsをtrueにするだけでなく、
　移動元のマップのthereIsをfalseにしなければならない。
　currentLocation().thereIs = false;のようにしたいが、
　たとえばゲームの最初に森に行く場合を考えてみる。
　そうすると、currentLocation()はthereIsがtrueのMapを返すメソッドなので
　ゲームの最初は全てのthereIsがfalseになってしまっているため、
　必ずmountainMapが返ってきてしまう。何ならこれを利用してどうにかできないか？
　currentLocation()を行ったうえでmountainMap.thereIsがfalseになっているのなら
　全マップのthereIsがfalseになっているということ = ゲームの最初と言うことが分かる。
　というか今わかったけどこれ別に問題ないのでは？ゲームの最初に森にいったとして
　currentLocation().thereIs() = false;にしても元々falseだったmountainMapのthereIsにfalse念押ししてるだけだし、
　最初に山に行ってもmountainMap.thereIsにfalse設定した後にtrueにする処理を持ってきているので、
　恐らく問題ないわ。
　いやちょっと待ってくれ、currentLocation()ってforestMap.thereIsの内容を見るから
　これまだ他のマップのインスタンス生成されてなかったらまずくね？
　　→　フィールド宣言時の段階で　Map forestMap = new Forest;　のようにして解決。

・shopping()内でボスを倒している状況によって売るアイテム数を増やしたいと思い、
　表示するテキストについて考えている時に気づいた、
　今のままだと呪文を表示する時に整列しないでばらばらの状態で表示されてしまうのでは？
メラ：1
ホイミ：2
　のように表示されてしまう。そして、呪文表示とアイテム表示はプログラムの処理内容が似ている。
　そのためどちらかでいい方法が思いつけばもう片方にもそれを適用すればいい感じになるかもしれない。
　ただ、呪文の方は呪文の名前リストやらレベルリストやらいろいろ複雑なので
　アイテムの方で考えてみる。
　そのリストに入る最長の文字がわかれば、あとは他の名前は先頭に最長の文字との差分だけ
　先頭に空白を入れればよいのでは？呪文で考えると呪文で一番長いのは
　　→ 普通にcreateSpellNameListのところで代入する文字列の先頭に空白を入れればいいだけだった

・ボス討伐状況によって変えるアイテムが変わる、すなわちボスを倒す = アイテムが増える
　ならばこのアイテムが増える処理はボス討伐後、battleBoss内で行うべきか？
　レベルによって使える呪文が変わる、すなわちレベルが上がる = 使える呪文が増える
　上記では呪文が増える処理はレベルアップ後のcheckSpellUp()で行っている

　ただ、この2点の違うところは、レベルが上がっても呪文を習得するとは限らないが、
　ボスを倒したなら必ずbossKillCountに+1され、アイテムが増える、といったところ

　ならばアイテムテキストが加算されるか判定、ではなく　アイテムテキストを加算する、にして
　battleBossで勝った時にそのメソッドを置けばよいのでは？
　shoppingItemAdd(this.bossKillCount);　のようにして置けばよいのでは？

　またもやじゅもんとの違いだが、呪文はこのレベルに対してこの呪文、というように1対1の関係だった
　しかしアイテムはボスキル+1に対してアイテム2つ、というように1対2の関係となっている。
itemlist.add(i);
itemlist.add(i + 1);
i += 2;
　のようにすればできそうな気はするが、わかりづらい気がする。
　　→ ボスを倒せばアイテムが増えるのは確実なので、bossBattle()で勝った時の処理後に
　　　addItemFormat()を置くことにした。ボス1体討伐につき2つアイテムが加わるので
　　　shopItemList.get(0)とshopItemList.get(1)のように追加していきたいため、
　　　do whileで(this.itemIndex % 2 == 0)のようにした。こうすればdoで必ず一回は実行されるので
　　　最初のwhile判定の時は1,3,5になるのでもう一度ループし、次は2,4,6になるので
　　　そこでループが止まる。値は保存されるので次回のループは2,4から始まり、while判定で3,5になる…
　　　といった形の処理にした。

・checkLevelUpは今のところvoid型だが、int[]型にするのもあり
　元のレベルと上がった後のレベルを返すようなメソッドにして、
　levelUp()でその2つのレベルを用いてステータスアップを処理する、という感じにしたい
　それにはステータス上昇についてもそろそろ実装しなければならない…
　ステータス上昇はランダム値ではなく固定にしたいのでまずは適当にリストを作成するところから
　しかしステータス上昇リストを作るといっても、どのような形で作ればよいのか？
　固定値であればよいためある一定の範囲の数が順番に繰り返し加算されていく形はどうか？
　3～6の範囲ならレベル2　→　+3 レベル3　→　+4　レベル4　→　+5　のような形
　1つレベルが上がるに対して上昇するステータスはちから、まもり、すばやさの3つがある。

・所持アイテムフィールドは二次元配列にした方が良いか？
　持てる上限99個のアイテムが6種類ある。1つ目をアイテムの種類にし、2つ目を持てる個数にする。
　それかItemクラスに所持数フィールドを持たせるか
　そのアイテムを持っていない場合は所持アイテムには表示せず、入手した段階で
　所持アイテムに表示するのもなんか時間かかりそう

・HPやMPを回復する処理については、必ずMaxHpやMaxMpを用いて最大HPや最大MPを
　超えないようにする。その計算を必ずプログラム中に入れる。

・だいちのしゅくふくでHPは全回復させたいが、勇者のMaxHpをどうやって渡す？
　コンストラクタで回復量が決まってしまう、つまり生成時に決まってしまうため、
　レベル10の時に生成しただいちのしゅくふくをレベル11の時に使ったらそれは全回復ではなくなってしまう。
　これを解決するにはどうすればよいか？アイテム使用のシステム自体を見直す必要がある気がする。
　今のところuse() { return this.healPoint; }となっているが絶対にこれを改良できる気がする。
　use()の引数に勇者の現在HPと最大HPを渡すか？
　　→ 全回復アイテムの2つだけuse()をオーバーロードし、引数に勇者のHPと最大HPを持つことで
　　　恐らく全回復は可能となった。この2つに関してはコンストラクタで渡すminHealPointとhealRangeは
　　　意味を持たず、use()時に指定する引数が使われるので注意する。

・持っているアイテムの表示について

　どのようにすれば所持アイテム状況に応じたリストを表示することができるか？
　各アイテムごとにbooleanのスイッチみたいなものがあってfalseなら表示せず
　trueなら表示するみたいなことができればいいのに
　表示する文章はthis.itemFormatでいいか

・今はまだ8種類しかアイテムが無いためどんなプログラムにしても比較的簡単に実現できるが、
　もしゲームの規模を大きくして100種類以上のアイテムを実装したときに
　どんなプログラムが一番楽でミスが少ないかと言ったらやはりアイテムインスタンスごとに
　.use()を呼び出すことだと思うのでこれでいく。アイテムごとに処理内容を決め、
　アイテムゲット = アイテムインスタンス生成、そしてアイテム袋(フィールド)に入れる。
　アイテム使用 = アイテムインスタンス.use()を使用、そしてアイテム袋からそのアイテムを-1
　といった感じにする。
　なので今の問題としては「アイテム袋」をどういった形で持つか、といったことになる。

　アイテム袋 = new Yakusou();
　this.アイテム袋(やくそう).use();
　アイテム袋.remove(やくそう)

　みたいなことができるプログラムは何か？
　this.itemList.get(やくそう).use();　と言った形で使える？
　そしてthis.itemList.remove(やくそう)　とすればよい？
　this.itemList.add(new Yakusou();)　でアイテム袋に追加できる？

　しかしこのようにArrayListをアイテム袋に用いる場合、個数上限をどう実現するか？
　調べてみてもArrayListに各アイテムの上限を定める簡単な方法は特になさそう
　やはりItem[8][99]をフィールドに持った方が良いか？
　しかし配列を使う場合に懸念されるのは、最初のアイテムを使用しても勝手に順番を詰めてくれないのでは、ということ
　最後から使う方法もあるだろうが、制御構文で複雑になりそうなので
　簡単に配列が勝手に順番を詰めてくれるプログラムがありそうならそれを使いたい。

　もしくは、if (itemCount > 99) の場合、「それ以上アイテムを持てない」と表示して
　アイテムゲットをすっ飛ばす処理を入れる、と言う形でもよいかもしれない。
　ということは、haveCountフィールドを使用するのはアイテム入手時となる、
　つまりshopping()と敵がドロップしたときのみ。

・持っているアイテムによって所持アイテムのテキストを変えたい場合、
　itemCount == 0　は表示しないようにする、または
　itemCount > 0　だけ表示するようにする、またはそのどちらも使う
　上記でいけそうでは？itemCountフィールドを実装するなら
　アイテム袋を配列にしても1次元配列で済む。
System.out.println("かくにんするアイテムをせんたくしてください。");
for(int i = 0; i < 8(アイテム種類数); i++) {
    if (this.itemBag[i].itemCount > 0) {
        System.out.println(this.itemBag[i].getName());
    }
}

　1つ問題があるかも、アイテム袋を配列にした場合、配列の中身の初期値はnullであるため、
　this.itemBag[i].itemCountすら取得できないのでは？これがArrayListならどうか？
　for文内のitemBag.get(i)で格納されているだけの要素にアクセスはできそうだが、
　重複している要素を排除しつつ次々アクセスしていく方法はあるか？
　いや待て、そもそもitemCountをItemクラス側が持つならArrayListであるitemBagに格納されているのは
　入手済みのアイテムインスタンスだけでは？つまり生成されたアイテムインスタンスしか
　格納されないことになる。ということは最大でもitemBagに格納されるのは8つの要素だけ。
　ならばfor文内で
if (this.itemBag.get(i).itemCount > 0) {
    System.out.println(this.itemBag.get(i).getName);
}
　のようにすれば
　所持アイテムは表示できるのでは？となるとやはりArrayListを使った方がよさそうな気がしてきた

・各アイテムごとのuse()に対して勇者クラス側でアイテムを分ける処理がある
　その時配列のインデックスにアクセスする必要があるが、このままitemBag[0].use()や
　itemBag[1].use()とするとマジックナンバーになってしまうので避けた方が良い気がする
　あらかじめインデックス番号を定数としてクラス名にでも変換しておいた方が良いか
　あとアイテム種類数も

・今考えてるアイテム袋の実装方法(一次元配列)だと、アイテムを表示する時に入手順ではなく
　必ずアイテム順になってしまう。かなり余裕があれば「ソート」の実装についても考えてみたい。

・アイテムを購入やゲットする際の処理として、itemBagに既に要素が入っているかのチェックを
　行わなければならない。初入手ならアイテムインスタンスを生成してitemBagに入れなければならないし、
　2回目以降の入手ならitemBag内のそのアイテムのitemCountフィールドを+1するだけでよい。
　しかしどうやってチェックすればよいか？itemBagに入れる要素はアイテムクラス、つまり
　itemBag.contain()の()内に入れる値はクラス名でよいのか？
　itemBag.contain()はitemBag.add()の時に()内に入れた値を使用する、
　つまり　itemBag.add(new Herb());　とした場合、itemBag.contain()の()にどのような値を入れたらいいのかがわからない。
　ArrayListでは必要ないと思っていたが、配列のようにインデックス番号とアイテムを対応させた方が良い？
item.hpitem.Herb
item.hpitem.MedicineLiquid
item.hpitem.LifeHerb
item.hpitem.BlessingOfGround

indexOf(Herb) と lastindexOf(Herb) の2つを用いれば
　system.out.println(itemBag.get(i))を行っていく中で、itemBag.get(i)が表示する文字列の中に
　入手しようとしているアイテム名(仮にHerb)がなければ未入手、あるなら入手済み
　「アイテムを入手する時に、入手するアイテムが既に要素内に入っているかを知りたい」
this.itemBag.add(new Herb());
String str = this.itemBag.get(0);
if (str.contains(Herb)) {
    itemBag.get(0).itemCount++;
} else {
    itemBag.add(new Herb());
}

public void checkGetItem(String itemClassName) {
    if (this.itemBag.size() == 0) {
        this.itemBag.add(new itemClassName);
        return;
    }
    for (int i = 0; i < this.itemBag.size(); i++) {
        String str = this.itemBag.get(i);
        if (str.contains(Herb)) {
            itemBag.get(i).itemCount++;
        }
        this.itemBag.add(new itemClassName);
    }
}

　上記のプログラムを勇者クラスにおいてみたが、new クラス名();　のクラス名は引数で代わりを
　きかせることはできないらしい。引数に応じてnewの後のクラス名を変えるにはどうすればよいか？

・一応文字列の先頭文字だけ大文字にするプログラムは以下においておく

        String str = "shunsuke";
        char[] name = str.toCharArray();            // 文字列をchar配列に格納
        name[0] = Character.toUpperCase(name[0]);   // 文字列の先頭文字を大文字に変換
        String itemName = String.valueOf(name);     // 先頭文字が大文字に変換された文字列を変数に格納
        System.out.println(itemName);               // 変換後の文字列を出力(大文字であることを確認)

・先頭文字を取得　→　取得した先頭文字を小文字から大文字に変換　→　先頭の小文字と変換した大文字を置換
　引数にクラス名をString型でとってプログラム内で先頭文字を大文字に変換すれば
　new 変換後のクラス名　で使えるかなと思ったが、よく考えたらクラス名って先頭だけじゃなくて
　単語の区切りも大文字やん、てことでこの方法は使えなさそう
　じゃあどうすればメソッドの引数に渡した値をnew 生成したいアイテムのクラス名();
　の形に持っていけるのか？そもそもこの形を取らない方が良いのか？
　というかそもそも引数のitemClassNameって手打ちだからクラス名そのまま入れりゃいいのでは？
　変換とか必要ないのでは？

・createItem(String itemName) { new itemName; }　のように引数に応じて
　アイテムインスタンスを生成するようなメソッドを作るのは無理そう。

・そうびも買えるようにしたい。

・アイテム袋の上限は決まっていてもおかしくないので、itemBagはあらかじめインデックスを確保しておき、
　各アイテムは決められた位置に入るようにすればよいか？

・アイテムは1回で複数個買えるようにしたい。その時買える上限は99-haveCountで計算する。

・本来ならアイテム袋の上限 < アイテムの種類　なのでアイテムには「すてる」選択肢があるべきだが、
　今回はどうするか。余裕があればにするか。
　　→ 今のところはアイテムの数が減るのはアイテム消費だけなので、
　　　ItemクラスのminusHaveCount()は呼び出すとhaveCountが1減る、と言った処理内容にする。

・「データとロジックの分離」という考え方を参考に余裕があればスッキリさせる
　経験値リストやレベルアップステータス上昇リストは分離できるデータのはず

・this.itemBag.get(i).use()が使えないため、Itemクラスにuse()抽象メソッドを実装したが、
　これではだいちのしゅくふくとめがみのしゅくふくでuse()に勇者のHP情報を引数に取れない。
　これはどうすればよいか？HP上限は999(仮)として、その数字を渡して
　最大HPに収まる処理は勇者クラス側のheal()で行えばよいのでは？
　　→ minHealPointに999、Rangeを1として回復量は999しか返さないように実装した。

・HP回復アイテムとMP回復アイテムで回復するプログラムを記述する際、
　HP回復のはずがMP回復になってしまう、またその逆といったことが起こりうるのではないか？
　そうならないようなプログラムを考えたい。今のままだと完全にどのアイテムが
　どんな動きをするのかをこちらが把握していないとプログラム内で回復の処理が書けない。

・[進捗]defense()について経過ターン数を用いた判定の実装
　　　　アイテムの実装について考える
　　　　敵のアイテムドロップについて考える
　　　　ショップという概念も作る
　　　　お金について考える
　　　　レベルアップ時のステータス上昇リストを作成する
　　　　持っているアイテムによって表示するアイテムが変化するプログラムを考える
　　　　アイテム入手の際にアイテム個数の上限を上回った場合にそれを拒否するプログラムを実装する
　　　　setHp()の処理に回復の際、最大HPを越えないようにする処理を追加する

=========================================================================================================

ゲームのフロー

どのマップに行きますか？(mapChoose) → 選ばせる(return)
↓
選んだ数字に該当するマップを決める(仮に森だとする) → 選んだ答えによって決める(chooseMap,switch文？)
↓
森にやってきた！ → 表示する(system.out.println)
↓
勇者はどうする？(mapAction,while) → 選ばせる(return)
↓
選択肢によって行動が変わる(仮にsearchEnemyとする) → 選んだ答えによって決める(switch → battle)
↓
敵と戦う(Battle) → Battleの中で行動を選ばせる(while内でswitch) → 敵か勇者のHPが0になったら繰り返し終了
↓
戦いが終わる
↓
勇者はどうする？(mapAction,while)
↓


=========================================================================================================

呪文使用のフロー

「じゅもん」を選択(battle)
↓
呪文一覧を番号に対応させた形で表示(printf)
↓
呪文を選択
↓
選択された呪文によって呼び出すメソッドを変える(switch)
↓
その呪文インスタンスを

=========================================================================================================

アイテム使用のフロー

アイテムをゲットする
↓
アイテム画面を開く
↓
アイテムを使用する
↓
アイテムの効果が表れる
↓
使用したアイテムが無くなる

=========================================================================================================

アイテム初入手までのフロー

敵を倒してmoneyを稼ぐ(this.itemBagには何も入っていない)
↓
ショップへ行く(this.itemBagには何も入っていない)
↓
「やくそう」を買う(this.itemBagに既にやくそうがあるかチェックする)
↓
「やくそう」を初めて入手する(this.itemBagの0番目にやくそうが入る)
↓
もう1つ薬草を買う(2回目以降の入手)

=========================================================================================================

ミスや引っかかったこと、つまずいたことやわからないこと

・import map;としてもimport文にエラーが出現し、mapパッケージのファイルが読みこめない。
　import map.Mapやimport spell.Spellだとちゃんと認識してくれる。
　だけどいちいちattackspellやhealspellとかもimportで記述しないといけないのは面倒。
　　→ そもそもimport文は「import パッケージ名.クラス名」のようにクラス名まで記述する必要があるため、
　　　import map;のように「import クラス名;」でエラーが出るのは当然。単に基礎知識不足だった。
　　　「import Map.*」や「import spell.*」とすることによって解決。

・