javaゲーム メモ

・文章が表示される間隔を2秒ぐらいにしたい
　(欲を言えばクリックするごとに表示させたい)

・フィールドで勇者のaction()メソッドを呼び出す感じにする。
　action()メソッドは、どのアクションを行いますか？と表示し
　討伐、探索、休む、マップ移動などを選択肢で表示する。

・while (イベントカウント) {
    action();
    
}

・各フィールドのクリア条件は、討伐と探索を決められた回数クリアしたらにする
　決められた回数クリアしたら強制的にイベントに進ませるのではなく、
　mapActionに「ボス戦」の選択肢を追加する
　「(マップの奥地が解放された！十分な準備をしてからここに進もう」などのテキスト)

・3つあるフィールドはそれぞれ微妙に難易度が違うようにするのか、
　それとも同じようにするのか。

・探索はお宝を得られるチャンスのため、リスクがあった方がおもしろいのでは？
　中ボスを配置するなど

・どうのつるぎ、はがねのつるぎなどはmainプログラムの方で生み出す感じとなる。

・ターン制バトルをどうやって実現する？

・while(勇者のHPが0になるか、敵のHPが0になるか、どちらかが逃げるか) {
    battle();
}

・勇者の最大HPはどのように定義すればよいのか？ → 勇者クラスに専用の変数を定義
　レベルアップの時だけこの変数を呼び出すようにする。

・じゅもんを選択したがやはり違うことをしたいなどといったときに、
　もどれるプログラムもほしい

・レベル上限は20とする

・[進捗]battle()メソッドに渡す敵の引数について、マップごとに敵情報を変えて渡すにはどうすればよいか？
　　　　

・敵を倒した時に1体の敵を倒したときと複数の敵を倒した時の挙動を変えるには？？
　そもそもbattle()メソッドに複数の敵インスタンスを渡したい時にはどうすればよいのか？
　敵の数という情報は配列の形にした方が良い？
　それならbattle(Enemy[] e) とすればその配列の中身が単体でも複数でも想定しているプログラムになるはず
　「e[0].name + "と" e[1].nameをたおした！」のような記述になる
　ただ問題点が1つ、同じモンスターを複数倒した場合に「スライムとスライムをたおした！」ではおかしいので
　equals()のようなメソッドを用いて渡された配列内のモンスター名を等価か判断する必要が出てくる。

    if (配列内のモンスター名が重複していない場合){
        System.out.println(e[0].name + "と" + e[1].name + "をたおした！");
    } else {
        System.out.println(e[0].name + "をたおした！");
    }

　なお、上記のプログラムは2体を想定しているので数が増えればもっと複雑になる
　まあ簡単なゲームなので敵の最大数は3体でもいいし、このゲームはドラクエ1ライクのつもりなので
　なんなら敵は全て単体でもよい

　ちなみにもしこのプログラムを利用するならば、敵が生成される時に配列に入れる順番は
　名前を辞書順で入れると同じモンスターは必ずインデックスが連番で入るので
　それを利用して重複を確かめることにすると楽になるかも

・levelList.addももうちょい見やすく短い方法で記述できたら良い
　for文で決まった数だけ上乗せしていって周回数が一定の回数になったら
　さらに必要経験値を上乗せしていくなど
　この形のようにレベルが上がれば上がるほど必要経験値も上がっていく
　"比例"のようなプログラムを作るにはどうしたらよいのか？
　y(必要経験値) = ( 〇(現在のレベル) * x(定数) )
　上記のような形でいけるか？今回は以下の式を採用

    while (int i < 21;) {
        levelList.add(levelPoint)
        levelPoint = (int)( (levelPoint + this.level) * 1.25);
        i++
    }

・Spell healSpell = new HealSpell();
　Spell attackSpell = new AttackSpell();
　で勇者が持つ呪文インスタンスを2種類に分けて生み出し、使う時は
　brave.healSpell.hoimi();　のようにして呼び出す。

・仮に呪文の上限が5個だとして、(ホイミ(3)、メラ(5)、ベホイミ(9)、メラミ(14)、メラゾーマ(17))
　呪文一覧を表示する際にレベルアップの状況に応じてその時点で習得している呪文を表示するには？
　レベルアップのメソッドに呪文を紐づける必要がある。そして、勇者クラスに呪文一覧表示のフォーマットを
　作成し、レベルアップのときに呪文を表示するフォーマットに習得した呪文を増やすプログラムを書く必要がある。

・経験値とレベルはマップにして対応表みたいな形で扱えばよいのでは？(むずそうなので保留)

・呪文に番号を振る形に決定する。

    switch(spellChoice) {
        case 1:
            healSpell.hoimi();
            break;
        case 2:
            attackSpell.mera();
            break;
        case 3:
            healSpell.behoimi();
            break;
        case 4:
            attackSpell.merami();
            break;
        case 5:
            attackSpell.merazoma();
            break;
        default
            // 想定外の数値が選ばれた場合はもう一度選びなおさせるようにしたい
    }

・呪文表示用のString型フィールドを用意し、「\n%s：2」のようにして呪文表示のフォーマットに追加していく

・レベルがまだ低いときに「つかえるじゅもんがない！」と表示して戦いの選択肢に戻すプログラムも欲しい

・じゅもんやアイテムを選択した後、戻る選択肢は0とし、returnすればbattleメソッドに戻れる

    if (this.level > 2) {
        system.out.println("つかえるじゅもんがない！")
        return;
    }
    if (this.level > 2 && this.level < 5) {
        System.out.println("ホイミ：1")
    }
    if (this.level > 5 && this.level < 9) {
        System.out.println("ホイミ：1\nメラ：2)
    }

・上記のようなプログラムだと、「じゅもん」を選択したときにいちいち計算を行わなければならない。
　その都度計算してそれに対応する物を表示するのではなく、もう用意してあるものをポンと表示したい。
　そうするにはフィールドでフォーマットを持つのが一番良いと思うが、それの上手い扱い方が分からない。
　レベルに応じてフォーマットにどうやって追加していけばよいのか？
　一番想像がつくのはcheckSpellUpに合わせて呪文一覧のフォーマットにも追加していくといった形。

・呪文一覧のフォーマットをレベルごとに合わせて表示するのは恐らく解決したが、
　このままのswitch文でいくとじゅもんをまだ1つしか習得していないのに4を入力すると
　メラミが使えてしまうプログラムになっている
　これを直すにはどうすればよいか？switch文の中でif文やcheckSpellUpの何らかの要素を使って
　判定することはできないか？
　　→　各呪文メソッド内でレベルチェックを行うようにする

・Spellメソッドの中でthis.spell.healSpell.hoimi()のようにはできない、
　なぜならSpell spell = new healSpell();を勇者クラスで行わなければならないから。
　これはmainメソッドで行う予定だが、ではspellメソッドはどうすればよいのか？

・習得したタイミングでそのじゅもんインスタンスをうみだせばよいのでは？
　しかしホイミを習得 → HealSpellインスタンスを生み出すと
　何らかの手違いでベホイミが使えてしまうのではないか？

・敵をランダムにわかせる方法とは？
　そのマップに出現する敵の種類の数だけ乱数を作成して(3種類なら「1～3」を乱数プログラムで作成)
　その値によって出現する敵を変える(1ならスライム、2ならゴブリン…みたいな感じ)
　これを勇者クラスのsearchEnemyでやるのは割と理にかなっているのでは？結構いいかも
　一瞬マップ間で敵の種類数が異なる場合どこで差異をつけるんだ？と思ったが、
　if文の中に乱数生成プログラムがあるなら全く問題なかった

・それぞれのマップに出現する通常敵の数は

　森　→　3種類
　海　→　4種類
　山　→　6種類

　にする

・上記は敵を探すときのプログラムだが、お宝を探すsearchTreasureでも同じように
　マップ属性を使えばいいかんじになるのでは？

・敵アイデア

　森
　　スライム、ウルフ、キラービー
　海
　　ひとくいザメ、かいぞく、
　山
　　デスイーグル、がんせきまじん、マグマゴーレム、

・たとえば、その地のお宝を1つ以上見つけ、敵を4体以上倒せばボス解放。
　ボスフラグを勇者クラスのフィールドに定義する。
　chooseMapActionメソッド内のswitch文にはあらかじめcase 5:も定義しておき、
　そこに記述される仮にbattleBoss()メソッドの先で以下のプログラムを書いておけばよいのではないか？

　if (ボスフラグ == off) {
    return;
} else if (ボスフラグ == on) {
    chooseMapActionで表示する文字列変数 += "ボスとたたかう：5"
}

・マップ間の移動がマップアクションで選べるならば、各マップでボスフラグの進行状況は違う
　仮に森：4(ボス出現)　海：3(ボス未出現)　山：7(ボス出現)だとすると
　森にいる場合は5：ボスバトルが表示され、
　海にいる場合はまだ表示されず、
　山にいる場合は5：ボスバトルが表示される。

　森　　　海　　　山
　this.mapAttributeには現在いるマップ名が格納されている。
　this.forestBossFlagにはボスバトル解放のための行動回数がカウントされている。
　「今いるマップ」のボスフラグをカウントする形にもっていければよい？
　そのマップに初めて訪れる時にそのマップのインスタンスを生成するのはどうか？
　勇者が持つMapフィールドに現在いるMapインスタンスをセットすれば現在いるマップが分かる？
　this.map = new Forest();

　マップクラスはフィールドにEnemyクラスを持てると思うのだがそれはどうか？
　map.enemy = new Slime();

　マップクラスに乱数によってランダムに敵を生成するメソッドを実装するのはどうか？
　そうすれば勇者クラスのsearchEnemyメソッドがもうちょっと見やすくなるのでは？
　public Enemy createEnemy() {
    int enemyNumber = new java.util.Random().nextInt(3);
    switch(enemyNumber) {
        case 0:
            Enemy = new Slime();
            break;
    }
}

switch(this.map.getName) {
    case "森":
        Enemy enemy = this.map.createEnemy;
}

・勇者クラスのmapを現在地にするならば、つまりthis.map.createEnemy()はその現在地の敵を作ることになる？
　ということはsearchEnemyでマップによってswitch文で振り分ける必要がなくなる？
　　→ 結構いい感じにいけそう

・createSpellNameList(呪文名リスト)とcreateGetSpellLevelList(呪文習得レベルリスト)の2つは
　どうにかマップにまとめていい感じにプログラムを簡単にできないか？

・そのマップをクリアしたらマップ名は「森(クリア！)」のようにしたい
　そのため、勇者クラスのthis.map.nameを用いて判別するようなプログラムは
　その変数の名前.equals("森")などにするのではなく、"森"が含まれているかどうかで判別するようにしたい。

・敵の攻撃をどうやって実装すればよいか？勇者クラスでbattleメソッドを実装しているが、
　そうするとe.attack()の引数に勇者インスタンスを持ってこれない
　battleクラスを作るのもアリ、「戦い」は勇者だけのものではなく客観的に見て
　勇者と敵の戦いなのでクラスとして独立していてもおかしくはない、はず
　しかし結局勇者インスタンスの引数をどうすればよいかは解決していない

・勇者クラスは今のところ攻撃力と守備力のみだが、これは自身のステータス + 装備合わせた数値であって
　勇者自身のステータス用の攻撃力(ちから)と守備力(みのまもり)も必要では？
　　→ 追加済み

・chooseMapActionのwhileが終わりを迎える条件は「全てのマップのボスを倒したら」になる。
　3つのマップのボス勝利状況を把握するにはどうすればよいか？

・敵の行動は引数なしのe.turn()で実装して、ダメージだけ戻り値にして
　その戻り値を勇者クラス側で計算すればよいのでは？
　敵が自身を回復する行動にした場合は戻り値をマイナスにして勇者側では何もしないようにする。
　これなら勇者クラスで全て行えるのではないか？

　damage = e.turn();
　this.hp -= damage;
　if (damage < 0) {
    return;     // 敵が自身のHPを回復するかもしれないので、負の値が返ってきたら敵の回復を意味する
}

・上記のような形で、回復呪文と攻撃呪文の使い分けもできそうな気がする
　呪文メソッドは戻り値を回復値とダメージ値にしてspellフィールドにattackSpellが入ってるなら敵にダメージ、
　healSpellが入ってるなら自分のHPを回復、のように分岐させることができるかもしれない
　それか単純に今のswitch文で　this.hp += healSpell.hoimi();　のような形でもいいかもしれない

・勇者と敵のHPを常に把握するようなプログラムはどうすればよいか？今のままだと
　「どちらかのHPが0になったら」の判定をメソッドの最初で行っているので、
　ターンの先攻でどちらかのHPが0になってもそれを検知するプログラムがまだ実装されていない。
　　→　勇者ターン(switch文)と敵ターン(e.turn)の間にifプログラムを入れる形で実装する。

・呪文メソッドで
　1．レベルのチェック
　2．ランダムにダメージや回復量を生成する
　は共通しているので、これをSpellクラスに実装して各Spellクラスで利用すれば見やすくなるのでは？
　　→　静的メソッド内でsuperを使えないため、各Spellクラス内にこのメソッドを置くようにした

・ラスボス戦の仕様をどうするか、ラスボスマップに行って「ラスボスと戦う」選択肢を出すのは少し違う気がする
　3つのマップのボスを倒すと「まおうのしろ」が解禁され、そこを選択すると
　「さいごのたたかいがはじまります。とちゅうでもどることはできません。」
　「さいごのたたかいにむかいますか？」みたいなテキストを表示させて、
　まおうのしろに行くとラスボスの刺客 → ラスボスの連戦が始まる、というのはどうか

・3つ目のマップのボスを倒せばchooseMapActionの5番選択肢がそのマップのボス戦 → ラスボス戦
　になるだけだが、1つ目、2つ目のマップではどうするか？そのマップにおいては一旦削除する処理も入れなければ
　削除する処理をデフォルトにしてその前にif (ラスボスフラグ == on)などを入れて判定する？

・お宝探しは、最初の1,2回はやくそうなどのアイテムをリスクなしで手に入れることができ、
　その後の1回は強い装備を手に入れることができる。しかし3回目の宝探しに行こうとすると
　「じゃあくなけはいをかんじる。さきにすすみますか？」のようなテキストを表示し、
　進む場合は中ボスぐらいの強さの敵と戦わせて勝てばお宝がもらえるようにする。
　進まない場合はまたchooseMapActionに戻る。

・今のところMapクラスに敵カウントやら宝フラグ、ボスフラグをフィールドとして持たせているが、
　これはマップ間を自由に移動できる場合、マップ選択のメソッドが呼び出されるたびに
　this.map = new Forest();のようになってしまっているので
　今のままではマップを選択するたびにフィールドが初期化されてしまうのでは？
　マップも自由に行き来できるのではなく、森 → 海 → 山 の流れでプレイさせるのが無難か
　しかしそうしても今のままだと初期化されていろいろおかしい点が出てきてしまう。
　インスタンス間で共有できる変数が無かったか？それを使えばよいかもしれない
　　→ 各マップにstaticで実装

・this.map.getBossFlagやthis.map.bossFlagが上手く機能しないため、
　this.map → this.forestなどのようにする必要がある

・static変数の内容を変えようとすると勇者クラスもstaticメソッドにしなければならなくなる

・Mapクラスに3つのマップのカウントを持っても上記が問題となる

・// 攻撃のダメージは自身の攻撃力～自身の攻撃力 + 2 の範囲内からランダム
// だけど攻撃力が高ければ高いほどその範囲も大きくしたい
// 最大値が最低値の倍以上になったらそれはやりすぎなのでそこでセーブしたい
// 攻撃力が2 → 2～4ぐらい　振れ幅は 2
// 攻撃力が30 → 30～38ぐらい　振れ幅は 8
// 攻撃力が4上がるごとにrangeに +1 されるような公式
// this.attack % 4 = 0 なら range = 1;
// this.attack % 4 = 1 なら rangeに +1
// つまり最終的なrangeは (this.attack % 4) + range で表せる？

・敵が逃げるかどうかの判断は、自身と勇者のレベルを比較し、勇者の方が高ければ高いほど
　逃げる確率は高くしたい。なのでe.turn()の最初にはまずそれを比較して
　逃げる確率まで算出するプログラムを挟みたい、そのプログラムはEnemyクラスに実装する
　
　勇者のレベルが自身と同じまでは逃げる確率 = 0にしたい
　例えばスライムならレベルが2なので勇者のレベルが1、2なら絶対に逃げない
　勇者のレベルが3なら5%ぐらいの確率で逃げたい　レベル差 = 1　確率は　5　アップ
　勇者のレベルが10なら40%ぐらいの確率で逃げたい　レベル差 = 8　確率は　40　アップ
　勇者のレベルが15なら80%ぐらいの確率で逃げたい　レベル差 = 13　確率は　80　アップ
　つまりレベル差が1つあるごとに逃げる確率を5%アップすればよい？
　これを式にすると　braveLevel - this.level = levelGap(levelGapが0以下なら逃げない)
　逃げる確率 = levelGap * 5;
　　→　これに加え、範囲が100の中から乱数を生成し、その乱数がlevelGapの数以下なら逃げる、
　　　　levelGapの数より大きいなら逃げない、といった処理にした。

・スライムの行動に「スライムはぷるぷるとうごいている」を追加し、この行動の場合勇者にダメージは入らないので
　メソッドの戻り値は-1にしたい。他にも勇者にダメージを与えない敵の特殊な行動は負の値を返すようにしたい
　(負の値ならif(戻り値 < 0)で勇者にダメージが入るかどうかの判定ができるし
　特殊な行動が複数あった場合に-2,-3…と増やしていけるから)
　そうすると、逃げるフラグは0になる、しかしenemyAttack - braveDefenseなどの計算で
　勇者の防御力が敵の攻撃力を上回った場合にも戻り値は0になってしまうため、
　この2つの0をどうやって判別するのかが問題
　EnemyクラスのbattleFlagを使えばよいのでは？というかそのために作ったような
　しかし攻撃前にbattleFlagを読み取って逃げるかの判定を行うのが難しい、どこで判定すればよいのか？
　逃げるかどうかの判定はe.turnに組み込まず、brave側で判定すればよいのでは？
　　→ 敵が逃げるかの判定はe.turn()内で行わず、brave側でe.runJadgement()を呼び出すことにした。
　　　そして勇者にダメージが入らない特殊な行動についてテキストの表示や
　　　特殊なステータスの計算は敵側の行動メソッドで処理を行い、
　　　勇者側にはダメージが無いことだけ伝えることにした(return 0;)
　　　勇者の防御力が敵の攻撃力を上回った場合、0ポイントのダメージ！のように表示されてしまうが、
　　　単なるミスと区別が付けられるのでこれはこれでよいかなと思った。

・敵が逃げた場合経験値は取得できないようにしたいが、
　勇者のHPが0になったのか、敵のHPが0になったのか
　敵が逃げたのか
　それらがターンの中間に行われたのかターンの終了に行われたのか
　ということはbattleメソッドの最後にif(this.hp <= 0) else {} などの処理を行うのではなく、
　勇者ターンで勇者が死ぬこと、敵ターンで敵が死ぬことはまずありえないので
　勇者ターンの終わりには敵HPの判定を、敵ターンの終わりには勇者HPの判定を行えばよいのでは？
　　→ 実装済み

・戦いの選択肢でたとえば「じゅもん」→「やっぱりやめる」のような流れは
　switch文の中でcontinueを使えば実現できそうか？
　　→ breakだと残った処理もしてしまうので、勇者が先攻だった場合残りの敵ターンも実行してしまう。
　　　よってcontinueで対応

・「ぼうぎょ」を選択した場合に、強制的に勇者は先攻となりそのターンが終わるまで防御力を増やす、
　または、先攻か後攻かは変わらず素早さで判断し、もし先攻ならそのターン終わりまで防御力を増やせばよい、
　もし後攻なら次のターンも強制的に勇者を後攻にし、その前の敵のターンは防御力を増やす
　という風に分けられるか？こういった場合の処理に対して勇者自身の経過ターン数を表す
　フィールドがあると便利、経過ターン数が+1されたらぼうぎょを解除するなど

・breakはそのメソッドの全てのループを抜ける、continueは今いるスコープのループを抜ける。
　このため、現段階でbattleメソッドでswitch文(勇者ターン)の処理が終わった時に
　一番大元のwhile文に行く方法がラベルしかない。しかしラベルはあまり使いたくない。

　てっきりcontinueは今いるスコープのループだけ終わらせるのかと思っていたが尚continueがどういう挙動なのかが
　わからなくなってしまった。同様にbreakも試してみたらまさかのbreakでも同じような実行結果となったので
　breakとcontinueがわからなくなってしまった。どういうこと？
　とりあえずどっちも今いるループは抜けて、大元のループに帰ってくれるらしい

        int a = 1;
        int b = 1;
        int i = 0;
        while(i < 3) {
            System.out.println("while--start");
            if (b == 1) {
                System.out.println("if--start");
                switch(a) {
                    case 1:
                        System.out.println("switch");
                        i++;
                        continue;　←　ここに注目
                }
                System.out.println("if--end");
            }
            System.out.println("while--end");
        }
        System.out.println("全てのループが終了");

　上記のコードの実行結果は以下の通り。

        while--start
        if--start
        switch
        while--start
        if--start
        switch
        while--start
        if--start
        switch
        全てのループが終了

　if--endとwhile--endが処理されていない。
　そして、continueをbreakに変えたときの実行結果が以下の通り。

        while--start
        if--start
        switch
        if--end
        while--end
        while--start
        if--start
        switch
        if--end
        while--end
        while--start
        if--start
        switch
        if--end
        while--end
        全てのループが終了

　continueでは実行されなかったif--endとwhile--endが実行されている。
　ここからわかることは、continueを用いると、その時点で大元の周回も含めて終了し、
　また大元のループからやり直す。
　breakを用いると、とりあえず今いるループだけを終わらせて残っている元の周回の処理をしつつ
　また大元のループからやり直す、といった挙動の違いになる。

・勇者か敵のHPが0になったらバトルを終了させるためにbreakを配置していたが、
　上記から大元のループに戻ってしまうことがわかったため、大元のwhile文の条件式を
　勇者HPと敵HPの判定 → 勇者か敵どちらかが死んだらの判定にした方が良さげ
　b.win()とb.die()でboolean型の変数か何かを変更し、
　それで判定するのが良さげ
　　→ 条件式を　while (!this.battleWin || !this.battleLose)　として、
　　　win()とdie()内でそれぞれのフラグをtrueに設定するようにした。

・攻撃にも3種類ある、ミス、通常攻撃、会心の攻撃　同じく敵にもこれがある。
　これも考慮しなければならない。attackは勇者と敵問わずミスと会心の一撃の確率は一緒にする
　ミスは10%、会心は5%ぐらいでいいだろうか
　　→ 上記の確率で勇者と敵のattackメソッドに実装

・this.turnCount += 1;　の処理を各メソッド(attack(),spell(),defense(),useItem())内で行うようにすれば、
　spell()とuseItem()に関してはif(入力値 == 0) {turnCountに+1せずにメソッド終了}のようにして、
　battle()の勇者ターンの最初に while(turnCount < (turnCount + 1)) とすれば
　0で戦いの選択肢に戻ってこれるのでは？
　　→ 上記の通りに実装済み

・戦いが終わる条件は4つ、勇者のHPが0、敵のHPが0、勇者が逃げる、敵が逃げる
　これをbattle()のwhile条件式に記述しなければならない
　　→ 4つの条件のフラグを勇者クラスに追加し、それで判定するwhile条件式を実装済み
　　　ターン区切りに配置されるdie()やwin()、run()の後にはcontinue;を記述
　　　(breakだと残りのループ処理が実行されてしまうため、continueなら一番最初のwhileに戻ってくれるから)

・アイテムは何を用意すればよいか？今回のゲームではHP回復とMP回復だけでよいのでは？
　(本当は状態異常を治したり付与したり、必ず逃げられるアイテムとかも用意したいが、これは余裕があれば)

・アイテムの説明表示はchooseMapActionのアイテム確認のみで行えるものとしたい
　「せつめいをひょうじしたいアイテムを選択してください」のようなテキストを表示して選ばせる
　バトル中にも表示できるようにはしたいが、ゲーム画面がごちゃごちゃしてしまいそうなので無し
　ということはじゅもんとそうびもアイテム同様、chooseMapActionで確認できるようにしたい
　これらは「自身が所持しているものの確認」といった点では同じなのでまず
　どの項目を確認する？　→　じゅもん：1　そうび：2　アイテム：3　のような形で枝分かれさせ、
　その先でもどのじゅもん、どのそうび、どのアイテムを確認するのかを選ばせて説明を表示させる。

・useYakusou() {
    Item yakusou = new HpItem(10,5);   // やくそうを作成、10～5の間で回復
    if (yakusou.count == 0) {
        return;     // やくそうの所持数が0なら使用できない
    } else {
        yakusou.use();  // 使用して体力回復
    }
}

・ただやすめるだけだとゴールドと言う概念がある意味がないので、
　宿で休むに変更してゴールドを消費するようにする
　そして、ショップを用意してアイテムを買えるようにする
　そうなってくると、「おたからをさがす」選択肢が必要かどうか疑問になってくる
　薬草などのアイテムはショップで買えるようになるし、
　つよいそうびは「そのマップのボスを倒したら手に入る」でよいのでは？
　それか、マップボスはもう最初から挑戦できるようにして(当然いきなり勝てるような相手ではないが)
　ある程度そのマップの敵を倒したら「ひきょうのちをはっけんした！」
　「おたからのけはいがする…」と表示し、秘境を解禁して
　そこの中ボスを倒したら強い装備が手に入る、みたいにしてもよいかも
　マップボスに挑戦する際、こちらが想定しているレベルに満たない場合は
　「きびしいたたかいになることがよそうされます。それでもいどみますか？」みたいな文を表示してもよい
　レベルを満たしている場合は「ほんとうにいどみますか？」だけにするなど

・アイテムはArrayListの形でもって、リストに要素があればuse()で
　リストに要素が無ければつかえない、と言った形でよいのでは？
　アイテムを手に入れる時はget()なりを用意し、リストに要素を1つ追加する。

List<String> itemList = ArrayList<String>();

public void getItem(String itemName) {
    item.add("yakusou");
}

public void checkHaveItem(Item item) {
    if (this.itemList.contains(item.getName())) {
        useItem(item);
    } else {
        System.out.println("アイテムをもっていない！");
    }
}

public void useItem(Item item) {
    
}

this.hp += yakusou.use;

ゲット時の処理
Item item = new Yakusou();
itemList.add(item);
使用時の処理
itemList.contains()
itemList.remove(item);
itemList.add(createItem("yakusou"));

・アイテムリストにはアイテム名を格納し、そのアイテムを使いたい時、
　アイテムリストの先頭から使いたいアイテム名に一致するものを探していく。
　一致した要素を使用 = リストから削除し、回復処理を行う。

・アイテムは戦闘中だけでなくマップ内アクションのアイテム確認からも使えるようにしたい
　なぜならやどやより薬草の方が安い場合、そっちで回復したいユーザーもいるだろうから

・現段階ではレベルアップ時のステータスを考えていないのでは？これも考える

・アイテム上限は各アイテム99個とする、そうしたら配列が使用できる？

・単純に考えて、アイテムを入手する状況は2つしかない。
　自分で買う時と、モンスターがドロップする時。
　買えるアイテムはレベルの進行具合、もしくはマップの進行具合によって順次増やしていきたい。
　マップクリアごとに商品入荷、など。
　これを実現したい場合、各マップ.bossKillのtrue数をカウントするプログラムが必要になる。

・果たして本当にMapクラスにボスを倒したかどうかの判定や、敵を倒した数のフィールドを実装する必要があるか？
　createEnemy()はマップごとに敵の情報が違うためマップは敵の情報を持っている=createEnemy()はMapクラスに
　実装したが、ボスを倒した、敵を倒したなどの情報は別に勇者クラスが持っていてもよいのでは？
　Mapは1つしか存在しえないのにそのマップに移動するたびにMapインスタンスが生成されなおすというのも
　おかしいとは思うが、ならばMapインスタンスを保存する方法を考えるべきか？
　勇者クラスにforestMap、seaMap、mountainMapの3つのフィールドを持って
　今いるマップはtrue、いないマップはbooleanのようにすべきか？
　各マップのフィールドにboolean there;のようなフィールドを用意して、今いるマップはそれがtrueになる、など
　そうすればchooseMapの時もif (this.forestMap == null) のようなチェックができる。
　こうすれば各マップは1つしか生成されなくなる

・そのマップの中でも弱い敵、強い敵がいるため出現確率は同じではなく弱い敵ほど出やすいようにしたい。

・マップ内アクションを表示する時など、thereIsがtrueになっているマップの情報を表示したい時
　どうすればよいか？forestMap.thereIs,seaMap.thereIs,mountain.thereIs の3つ
　この3つのどれがtrueになっているか調べ、trueになっているマップの任意の情報を取り出すには？
　if (forestMap.thereIs) { enemy = forestMap.createEnemy(); }
　敵を作るのはこれでできそうだが、問題はマップ内で一定の敵を倒したら選択肢に現れる
　「ひきょうをたんさく」について。これを表示するには
　マップの敵キルカウントを調べ、一定数以上ならテキストを追加で表示する
　if (forestMap.enemyKillCount > 5) { str += うんたらかんたら}
　プログラムが少しわかりづらくなってしまうが、今のところはこれでいいか
　というかこれの判別用メソッドを別で作って、それを呼び出す形にしたい
　3つの内のどれかのマップ.createEnemy();のようにしたいので
public Map hogehoge() {
    if (this.forestMap.thereIs) {
        return this.forestMap;
    } else if(this.seaMap.thereIs) {
        return this.seaMap;
    } else {
        return this.mountainMap;
    }
}

・マップ移動の時、移動先のマップのthereIsをtrueにするだけでなく、
　移動元のマップのthereIsをfalseにしなければならない。
　currentLocation().thereIs = false;のようにしたいが、
　たとえばゲームの最初に森に行く場合を考えてみる。
　そうすると、currentLocation()はthereIsがtrueのMapを返すメソッドなので
　ゲームの最初は全てのthereIsがfalseになってしまっているため、
　必ずmountainMapが返ってきてしまう。何ならこれを利用してどうにかできないか？
　currentLocation()を行ったうえでmountainMap.thereIsがfalseになっているのなら
　全マップのthereIsがfalseになっているということ = ゲームの最初と言うことが分かる。
　というか今わかったけどこれ別に問題ないのでは？ゲームの最初に森にいったとして
　currentLocation().thereIs() = false;にしても元々falseだったmountainMapのthereIsにfalse念押ししてるだけだし、
　最初に山に行ってもmountainMap.thereIsにfalse設定した後にtrueにする処理を持ってきているので、
　恐らく問題ないわ。
　いやちょっと待ってくれ、currentLocation()ってforestMap.thereIsの内容を見るから
　これまだ他のマップのインスタンス生成されてなかったらまずくね？
　　→　フィールド宣言時の段階で　Map forestMap = new Forest;　のようにして解決。

・shopping()内でボスを倒している状況によって売るアイテム数を増やしたいと思い、
　表示するテキストについて考えている時に気づいた、
　今のままだと呪文を表示する時に整列しないでばらばらの状態で表示されてしまうのでは？
メラ：1
ホイミ：2
　のように表示されてしまう。そして、呪文表示とアイテム表示はプログラムの処理内容が似ている。
　そのためどちらかでいい方法が思いつけばもう片方にもそれを適用すればいい感じになるかもしれない。
　ただ、呪文の方は呪文の名前リストやらレベルリストやらいろいろ複雑なので
　アイテムの方で考えてみる。
　そのリストに入る最長の文字がわかれば、あとは他の名前は先頭に最長の文字との差分だけ
　先頭に空白を入れればよいのでは？呪文で考えると呪文で一番長いのは
　　→ 普通にcreateSpellNameListのところで代入する文字列の先頭に空白を入れればいいだけだった

・ボス討伐状況によって買えるアイテムが変わる、すなわちボスを倒す = アイテムが増える
　ならばこのアイテムが増える処理はボス討伐後、battleBoss内で行うべきか？
　レベルによって使える呪文が変わる、すなわちレベルが上がる = 使える呪文が増える
　上記では呪文が増える処理はレベルアップ後のcheckSpellUp()で行っている

　ただ、この2点の違うところは、レベルが上がっても呪文を習得するとは限らないが、
　ボスを倒したなら必ずbossKillCountに+1され、アイテムが増える、といったところ

　ならばアイテムテキストが加算されるか判定、ではなく　アイテムテキストを加算する、にして
　battleBossで勝った時にそのメソッドを置けばよいのでは？
　shoppingItemAdd(this.bossKillCount);　のようにして置けばよいのでは？

　またもやじゅもんとの違いだが、呪文はこのレベルに対してこの呪文、というように1対1の関係だった
　しかしアイテムはボスキル+1に対してアイテム2つ、というように1対2の関係となっている。
itemlist.add(i);
itemlist.add(i + 1);
i += 2;
　のようにすればできそうな気はするが、わかりづらい気がする。
　　→ ボスを倒せばアイテムが増えるのは確実なので、bossBattle()で勝った時の処理後に
　　　addItemFormat()を置くことにした。ボス1体討伐につき2つアイテムが加わるので
　　　shopItemList.get(0)とshopItemList.get(1)のように追加していきたいため、
　　　do whileで(this.itemIndex % 2 == 0)のようにした。こうすればdoで必ず一回は実行されるので
　　　最初のwhile判定の時は1,3,5になるのでもう一度ループし、次は2,4,6になるので
　　　そこでループが止まる。値は保存されるので次回のループは2,4から始まり、while判定で3,5になる…
　　　といった形の処理にした。

・checkLevelUpは今のところvoid型だが、int[]型にするのもあり
　元のレベルと上がった後のレベルを返すようなメソッドにして、
　levelUp()でその2つのレベルを用いてステータスアップを処理する、という感じにしたい
　それにはステータス上昇についてもそろそろ実装しなければならない…
　ステータス上昇はランダム値ではなく固定にしたいのでまずは適当にリストを作成するところから
　しかしステータス上昇リストを作るといっても、どのような形で作ればよいのか？
　固定値であればよいためある一定の範囲の数が順番に繰り返し加算されていく形はどうか？
　3～6の範囲ならレベル2　→　+3 レベル3　→　+4　レベル4　→　+5　のような形
　1つレベルが上がるに対して上昇するステータスはちから、まもり、すばやさの3つがある。

・所持アイテムフィールドは二次元配列にした方が良いか？
　持てる上限99個のアイテムが6種類ある。1つ目をアイテムの種類にし、2つ目を持てる個数にする。
　それかItemクラスに所持数フィールドを持たせるか
　そのアイテムを持っていない場合は所持アイテムには表示せず、入手した段階で
　所持アイテムに表示するのもなんか時間かかりそう

・HPやMPを回復する処理については、必ずMaxHpやMaxMpを用いて最大HPや最大MPを
　超えないようにする。その計算を必ずプログラム中に入れる。
　　→ 実装済み

・だいちのしゅくふくでHPは全回復させたいが、勇者のMaxHpをどうやって渡す？
　コンストラクタで回復量が決まってしまう、つまり生成時に決まってしまうため、
　レベル10の時に生成しただいちのしゅくふくをレベル11の時に使ったらそれは全回復ではなくなってしまう。
　これを解決するにはどうすればよいか？アイテム使用のシステム自体を見直す必要がある気がする。
　今のところuse() { return this.healPoint; }となっているが絶対にこれを改良できる気がする。
　use()の引数に勇者の現在HPと最大HPを渡すか？
　　→ 全回復アイテムの2つだけuse()をオーバーロードし、引数に勇者のHPと最大HPを持つことで
　　　恐らく全回復は可能となった。この2つに関してはコンストラクタで渡すminHealPointとhealRangeは
　　　意味を持たず、use()時に指定する引数が使われるので注意する。

・持っているアイテムの表示について

　どのようにすれば所持アイテム状況に応じたリストを表示することができるか？
　各アイテムごとにbooleanのスイッチみたいなものがあってfalseなら表示せず
　trueなら表示するみたいなことができればいいのに
　表示する文章はthis.itemFormatでいいか
　　→ itemFormatをフィールドに持ち、ボス戦の後で追加する形にした。

・今はまだ8種類しかアイテムが無いためどんなプログラムにしても比較的簡単に実現できるが、
　もしゲームの規模を大きくして100種類以上のアイテムを実装したときに
　どんなプログラムが一番楽でミスが少ないかと言ったらやはりアイテムインスタンスごとに
　.use()を呼び出すことだと思うのでこれでいく。アイテムごとに処理内容を決め、
　アイテムゲット = アイテムインスタンス生成、そしてアイテム袋(フィールド)に入れる。
　アイテム使用 = アイテムインスタンス.use()を使用、そしてアイテム袋からそのアイテムを-1
　といった感じにする。
　なので今の問題としては「アイテム袋」をどういった形で持つか、といったことになる。

　アイテム袋 = new Yakusou();
　this.アイテム袋(やくそう).use();
　アイテム袋.remove(やくそう)

　みたいなことができるプログラムは何か？
　this.itemList.get(やくそう).use();　と言った形で使える？
　そしてthis.itemList.remove(やくそう)　とすればよい？
　this.itemList.add(new Yakusou();)　でアイテム袋に追加できる？

　しかしこのようにArrayListをアイテム袋に用いる場合、個数上限をどう実現するか？
　調べてみてもArrayListに各アイテムの上限を定める簡単な方法は特になさそう
　やはりItem[8][99]をフィールドに持った方が良いか？
　しかし配列を使う場合に懸念されるのは、最初のアイテムを使用しても勝手に順番を詰めてくれないのでは、ということ
　最後から使う方法もあるだろうが、制御構文で複雑になりそうなので
　簡単に配列が勝手に順番を詰めてくれるプログラムがありそうならそれを使いたい。

　もしくは、if (itemCount > 99) の場合、「それ以上アイテムを持てない」と表示して
　アイテムゲットをすっ飛ばす処理を入れる、と言う形でもよいかもしれない。
　ということは、haveCountフィールドを使用するのはアイテム入手時となる、
　つまりshopping()と敵がドロップしたときのみ。

・持っているアイテムによって所持アイテムのテキストを変えたい場合、
　itemCount == 0　は表示しないようにする、または
　itemCount > 0　だけ表示するようにする、またはそのどちらも使う
　上記でいけそうでは？itemCountフィールドを実装するなら
　アイテム袋を配列にしても1次元配列で済む。
System.out.println("かくにんするアイテムをせんたくしてください。");
for(int i = 0; i < 8(アイテム種類数); i++) {
    if (this.itemBag[i].itemCount > 0) {
        System.out.println(this.itemBag[i].getName());
    }
}

　1つ問題があるかも、アイテム袋を配列にした場合、配列の中身の初期値はnullであるため、
　this.itemBag[i].itemCountすら取得できないのでは？これがArrayListならどうか？
　for文内のitemBag.get(i)で格納されているだけの要素にアクセスはできそうだが、
　重複している要素を排除しつつ次々アクセスしていく方法はあるか？
　いや待て、そもそもitemCountをItemクラス側が持つならArrayListであるitemBagに格納されているのは
　入手済みのアイテムインスタンスだけでは？つまり生成されたアイテムインスタンスしか
　格納されないことになる。ということは最大でもitemBagに格納されるのは8つの要素だけ。
　ならばfor文内で
if (this.itemBag.get(i).itemCount > 0) {
    System.out.println(this.itemBag.get(i).getName);
}
　のようにすれば
　所持アイテムは表示できるのでは？となるとやはりArrayListを使った方がよさそうな気がしてきた

・各アイテムごとのuse()に対して勇者クラス側でアイテムを分ける処理がある
　その時配列のインデックスにアクセスする必要があるが、このままitemBag[0].use()や
　itemBag[1].use()とするとマジックナンバーになってしまうので避けた方が良い気がする
　あらかじめインデックス番号を定数としてクラス名にでも変換しておいた方が良いか
　あとアイテム種類数も

・今考えてるアイテム袋の実装方法(一次元配列)だと、アイテムを表示する時に入手順ではなく
　必ずアイテム順になってしまう。かなり余裕があれば「ソート」の実装についても考えてみたい。

・アイテムを購入やゲットする際の処理として、itemBagに既に要素が入っているかのチェックを
　行わなければならない。初入手ならアイテムインスタンスを生成してitemBagに入れなければならないし、
　2回目以降の入手ならitemBag内のそのアイテムのitemCountフィールドを+1するだけでよい。
　しかしどうやってチェックすればよいか？itemBagに入れる要素はアイテムクラス、つまり
　itemBag.contain()の()内に入れる値はクラス名でよいのか？
　itemBag.contain()はitemBag.add()の時に()内に入れた値を使用する、
　つまり　itemBag.add(new Herb());　とした場合、itemBag.contain()の()にどのような値を入れたらいいのかがわからない。
　ArrayListでは必要ないと思っていたが、配列のようにインデックス番号とアイテムを対応させた方が良い？
item.hpitem.Herb
item.hpitem.MedicineLiquid
item.hpitem.LifeHerb
item.hpitem.BlessingOfGround

indexOf(Herb) と lastindexOf(Herb) の2つを用いれば
　system.out.println(itemBag.get(i))を行っていく中で、itemBag.get(i)が表示する文字列の中に
　入手しようとしているアイテム名(仮にHerb)がなければ未入手、あるなら入手済み
　「アイテムを入手する時に、入手するアイテムが既に要素内に入っているかを知りたい」
this.itemBag.add(new Herb());
String str = this.itemBag.get(0);
if (str.contains(Herb)) {
    itemBag.get(0).itemCount++;
} else {
    itemBag.add(new Herb());
}

public void checkGetItem(String itemClassName) {
    if (this.itemBag.size() == 0) {
        this.itemBag.add(new itemClassName);
        return;
    }
    for (int i = 0; i < this.itemBag.size(); i++) {
        String str = this.itemBag.get(i);
        if (str.contains(Herb)) {
            itemBag.get(i).itemCount++;
        }
        this.itemBag.add(new itemClassName);
    }
}

　上記のプログラムを勇者クラスにおいてみたが、new クラス名();　のクラス名は引数で代わりを
　きかせることはできないらしい。引数に応じてnewの後のクラス名を変えるにはどうすればよいか？

・一応文字列の先頭文字だけ大文字にするプログラムは以下においておく

        String str = "shunsuke";
        char[] name = str.toCharArray();            // 文字列をchar配列に格納
        name[0] = Character.toUpperCase(name[0]);   // 文字列の先頭文字を大文字に変換
        String itemName = String.valueOf(name);     // 先頭文字が大文字に変換された文字列を変数に格納
        System.out.println(itemName);               // 変換後の文字列を出力(大文字であることを確認)

・先頭文字を取得　→　取得した先頭文字を小文字から大文字に変換　→　先頭の小文字と変換した大文字を置換
　引数にクラス名をString型でとってプログラム内で先頭文字を大文字に変換すれば
　new 変換後のクラス名　で使えるかなと思ったが、よく考えたらクラス名って先頭だけじゃなくて
　単語の区切りも大文字やん、てことでこの方法は使えなさそう
　じゃあどうすればメソッドの引数に渡した値をnew 生成したいアイテムのクラス名();
　の形に持っていけるのか？そもそもこの形を取らない方が良いのか？
　というかそもそも引数のitemClassNameって手打ちだからクラス名そのまま入れりゃいいのでは？
　変換とか必要ないのでは？

・createItem(String itemName) { new itemName; }　のように引数に応じて
　アイテムインスタンスを生成するようなメソッドを作るのは無理そう。

・そうびも買えるようにしたい。

・アイテム袋の上限は決まっていてもおかしくないので、itemBagはあらかじめインデックスを確保しておき、
　各アイテムは決められた位置に入るようにすればよいか？

・アイテムは1回で複数個買えるようにしたい。その時買える上限は99-haveCountで計算する。

・本来ならアイテム袋の上限 < アイテムの種類　なのでアイテムには「すてる」選択肢があるべきだが、
　今回はどうするか。余裕があればにするか。
　　→ 今のところはアイテムの数が減るのはアイテム消費だけなので、
　　　ItemクラスのminusHaveCount()は呼び出すとhaveCountが1減る、と言った処理内容にする。

・「データとロジックの分離」という考え方を参考に余裕があればスッキリさせる
　経験値リストやレベルアップステータス上昇リストは分離できるデータのはず

・this.itemBag.get(i).use()が使えないため、Itemクラスにuse()抽象メソッドを実装したが、
　これではだいちのしゅくふくとめがみのしゅくふくでuse()に勇者のHP情報を引数に取れない。
　これはどうすればよいか？HP上限は999(仮)として、その数字を渡して
　最大HPに収まる処理は勇者クラス側のheal()で行えばよいのでは？
　　→ minHealPointに999、Rangeを1として回復量は999しか返さないように実装した。

・HP回復アイテムとMP回復アイテムで回復するプログラムを記述する際、
　HP回復のはずがMP回復になってしまう、またその逆といったことが起こりうるのではないか？
　そうならないようなプログラムを考えたい。今のままだと完全にどのアイテムが
　どんな動きをするのかをこちらが把握していないとプログラム内で回復の処理が書けない。

・初期　→　ふるびたけん、ふるびたかぶと、ふるびたよろい
　1体目ボス討伐　→　どうのつるぎ、どうのかぶと、どうのよろい
　2体目ボス討伐　→　てつのつるぎ、てつのかぶと、てつのよろい
　3体目ボス討伐　→　はがねのつるぎ、はがねのかぶと、はがねのよろい
　秘境のアイテム　→　ゆうしゃのつるぎ、ゆうしゃのかぶと、ゆうしゃのよろい

　秘境のアイテムを最も強くしたいが、そうなると秘境のボスをそのマップで最も強くしたい
　そして秘境が出現するまでの敵を倒す数ももっと増やさなければ

・オブジェクト指向を採用するなら、ショップクラスなども作った方が良いのでは？
　勇者、敵、ショップ、宿屋、マップ、装備、ボス、アイテム、秘境、テキスト、

・持っているアイテムの表示は、for文でアイテム袋の内容を一行ずつ表示する、でよいのでは？

・今オブジェクト指向の設計が良くわからなくなっている原因としては
　勇者クラス = 主体　と考えてしまっている
　各オブジェクトの生成についてわからなくなっている

　勇者クラスは登場人物の1つに過ぎず、勇者がメインと言うわけではない。
　確かにゲームの主人公は勇者だが、それはゲームする側に主人公が勇者だと感じさせられれば良いのであって
　ゲーム内容を処理するプログラム内でも勇者が主体として動く必要はない。
　もっと勇者クラスにまとまっている処理は分散できるはず。

　各オブジェクトのプログラム内の生成については、使い捨てのアイテムならアイテム入手のたびに
　newすればよいと考えることができるが、勇者は1人しかいないためnewするのは最初の一回きりであり、
　それ以降はずっと同じインスタンスと考えられる。操作しようとしているオブジェクトがこのどちらに
　属するのかを考えることが大事だと思っているが、例えば宿屋は勇者と同じで宿に泊まるたびにその姿を
　変えるわけではないのでnewするのは最初の一回きりだと思うが、それで実装が上手くいかない場合
　別に宿泊イベントのたびにnewしてもよいのだろうか？そうなってしまうプログラムは
　オブジェクト指向に沿ったプログラムとは言えない気がするので極力避けたい

　登場人物はクラスに、登場させる前にはインスタンスを生成、登場人物が持つ属性はフィールドに、
　登場人物が行う動作はメソッドに
　この考え方を持ってプログラムの構想を練る
　自分の考えるオブジェクト指向に沿っていないのでは？と感じた場合は一旦立ち止まって考えてみる

・どのアイテムを買うか、何個買うかのプログラムが難しい
　どのアイテムを買うかの時点で0を選んだらショップを出ていかなければならないため、
　その時点でswitch文は使えない。そして、何個買うかの時点でも0を選んだなら
　どのアイテムを買うかにもどるようにしたい。

・アイテム所持数の情報がItemクラスにフィールドとしてあるのはおかしいのでは？
　アイテムが持つ情報はアイテム自身の情報だけであって所持数は勇者が持つべきだと感じた。
　ただその場合どのように実装すればよいか？

　やはりアイテム袋は配列の方がイメージがつきやすい気がする。Item[]配列にはアイテムインスタンスが入る。
　そうすれば　newで生成して配列に格納したアイテム数 = アイテム所持数　となるため。
　そしてuse()が呼び出された場合、該当するアイテムインスタンスが入っている配列から
　1つ削除する、といったようにしたい。

　アイテム袋の配列は　Item[アイテム識別番号][アイテム所持数]　のような二次元配列としたい。
　アイテム識別番号は各アイテムクラスにpublic final int で決めればよいか？
　もしくはprivate final intにしたものをgetするメソッドを用意したり

　アイテム袋(配列)にそのアイテムが入っているのかどうかを調べる時、
　所持数の[]に要素が入っていなければ空とわかるが、
　その場合99回要素が入っていないかどうかを確認しなければならないはず。これは処理的に無駄ではないのだろうか？

　冷静に考えると、アイテム袋で作りたい配列と言うのは
　Item[][]　ではなく　int,Item[][]　のような形では？一次元目はアイテム識別番号だけ入っていればよいから

　一番理想なのはそのアイテムインスタンスのuse()メソッドを使った場合、
　そのインスタンスは消えてその分配列が前に詰めてくれたりすること。
　詰めてくれなくても配列の空いてるところに新しいインスタンスを入れられるのなら別にいいとはおもうが

　herb.use()とした際に、ItemBagクラスに各アイテムのuse()メソッドを使ったことはどう伝えればよいか？
　herb.use(ItemBag itemBag) itemBag.やくそうの個数 -= 1;
　勇者クラスはItemBagクラスをフィールドに持ち、ItemBagクラスはItemクラスをフィールドに持つ。
　this.itemBag.アイテム.use()　といった形になるはず。

　今わからないことをザックリまとめると、
　「アイテム使用時にアイテムを指定する賢いプログラムの記述の仕方がわからない」ことだと思う。

　アイテムのデータをcsvに分離したことで、Itemクラスのコンストラクタに
　「コンストラクタで決めたアイテム名に一致するデータを読み取る」処理を追加したい。
　そうすればアイテムが何百種類あっても各アイテムクラスファイルに打ち込まず、
　csvファイルを編集するだけでよくなる
　1行ずつ読み取り、その行に自身のアイテム名が含まれていればその行の情報を自らのフィールドに格納する。
　含まれていなければ次の行へ、といった処理にしたい。
　　→ とりあえずItemクラスのコンストラクタでcsvファイルを読み込んでデータをフィールドに格納することは
　　　できそうだが、これはゲームに登場する各アイテムの1つ上の親クラスで行った方が良いかもしれない
　　　なぜならアイテムによって効果が違うから。今は回復を行うアイテムしかないからItemクラスで取り入れても
　　　上手くいくとは思うが、これが一時的に攻撃力をあげたり、敵の素早さを下げたり、状態異常を付与したり…
　　　など色々なアイテムが出てきたときにデータファイルは当然別々となるため、
　　　必然的に子クラス側でそれぞれのデータファイルを読み取ることになるはず。
　　　(今回も本来ならItemクラスではなくHpItem、MpItemでそれぞれ行うのが良いはず)
　　　　→ やっぱ各アイテムクラスごとに実装した方が良いのでHpItem_DataとMpItem_Dataのcsvファイルを作成し、
　　　　　HpItemとMpItemクラスのコンストラクタでcsvファイルからフィールドへデータを読み込むようにした。

　アイテムを選ぶ際にもcsvファイルを使用すればよいのでは？
　プレイヤーにはどのアイテムを選択するかを"数字"で決めさせ、
　そのあとにcsvファイルからその数字(識別番号)を検索し、対応する名前を戻り値として返す。
　そうすれば　switch(対応する名前の戻り値)　のようにすれば、case "やくそう"　という風にできるのでは？
　しかしこうすると、あらかじめアイテムによって番号が決まってしまうため、
　アイテムを飛び飛びで所持している場合は番号もとびとびになってしまう。
　GUIならばアイテムにカーソルを合わせて選択すればユーザーにそんなことは意識させなくて良いのだろうが、
　CUIだから仕方ないと割り切るべきか
　いざ実装しようとしたときに気づいた。各クラスでデータファイルを分けるため、
　勇者クラスでアイテムを選択する時に指定するファイルが複数になってしまう。
　アイテム選択用にアイテム名と識別番号だけが対応したファイルを作成すればいけそう

　ItemBag内で使われるitemCountに各アイテムの所持数情報を格納するにはどうすればよいのか？
　ItemBagクラスでもcsvファイルを呼び出せばよいのでは？

　とりあえず配列の二次元目がnullではない数 = アイテム所持数にしようと思う。
　そのためには、アイテム所持数を知る = 配列のどこまで要素が入っているか確認するメソッドが必要。
　ItemBagクラスにはもう作ったが、勇者クラスにも実装する必要がある。
　というかdisplayItemBag()メソッドをItemBagクラスに作ればよいのでは？

　今はItemBag.item[][]の一次元目にはアイテムの種類数分だけの数を入れているが、
　数百種類のアイテムとなった時に同じようにすると、アイテム袋がとんでもない大きさになってしまうため、
　そこは自分で上限を決めて、その数にしてしまって良いと思う。

　勇者クラスのuseItem()はswitch文内のアイテム間の処理で違うところがhpHeal()かmpHeal()かだけなので、
　HP系かMP系かさえわかればもっと簡単にできる気がする。
　　→　アイテムデータファイルに「ターゲット値」のフィールドを追加し、itemLookUp()で
　　　 アイテムIDに対応するターゲット値によってhpHeal()かmpHeal()を使うようにif-elseで記述した。

　アイテム名に対応するアイテムIDを返すメソッドがあるとより便利そう
　アイテムIDを渡すとそのIDに対応する情報を全て返してくれるようなメソッドがあると結構良いかも
　　→　実装済み

・なんかbyte使えると面白そうなので、10進数を入力すると16進数を返すプログラムでも作りたい

・boolean型を引数に取るメソッドを作って、そのメソッド内でif (引数) のようにしたら
　なんかいろいろできそうな気がする、戻り値がbooleanのメソッドをその引数に取ることも可能だし

・冷静に考えたらbattleメソッド内のwhile (this.turnCount < (this.turnCount + 1)) って式無限ループでは？
　ターン開始時点のthis.turnCountを他の変数に格納しておいてそれとthis.turnCountを比べるようにしたい。
　turnCountを新たに決めるのではなく、EnemyクラスにもturnCountを実装すればよいのでは？
　this.turnCountとe.turnCountを比較しながらターン制バトルを進めていく形にできると良い気がする。
　　→　EnemyクラスにもturnCountフィールドを追加し、whileが無限ループにならないよう修正済み

・ファイルからアイテムのデータを読み込んで照らし合わせたりする処理において、
　現段階ではitemArray[0]　のような指定をしてしまっており、マジックナンバーになってしまっているため
　これをデータファイルのフィールド名で指定できるようなプログラムを作れたらなおよい(名前、値段　とか)
　ただかなり難しそうなので余裕があるときでよい

・アイテムショップで買ったアイテムを勇者クラスに返すにはどうすればよいか？
　sell()メソッドがint[]を返すようにしても、買うアイテムが何種類でそれぞれ何個かなんてわからないため、
　可変長の配列でないと返せない
　マップに　キー：アイテムID　値：購入数　の形で格納し、それを勇者クラス側でitemBag.increaseに
　渡していけばよいのでは？ということはsell()
　　→　ItemShopのsell()はキー：アイテムID　値：購入数　の形のHashMapを返すように実装し、
　　　 勇者クラスでそれをitemBag.increase()に渡す、といった処理にした

・sellメソッドとは別でお会計メソッドを作るか、sellメソッドで返すようにしている
　(アイテムID、個数)のマップを新しいマップにネストして
　キー：アイテムと購入数のマップ　値：値段のようにするか、どちらかがよさそう
　sell()で返されるマップを引数にとり、そのマップを順次処理して会計を決めるメソッドが一番よさそう

　思ったのだが、確かに現実ならお会計はまとめてするが、こういったゲームでは
　アイテムを買うごとに行うべきでは？この形に変更する

　勇者の所持金情報をItemShop内でリアルタイムで追うことは不可能。
　ならばショップのwhileループは勇者側で行った方が良いか？

　勇者クラスが持つメソッドの引数にthisを指定したらエラーは出ないのだが、
　これは勇者インスタンスを勇者クラス内のメソッドで引数に指定できるということ？
　勇者クラスをインスタンス化するのはMainメソッドなので無理だと思うのだが
　簡単にMainメソッドで試してみる
　　→　なんかできそうなのでsell()に勇者インスタンスを渡すことにし、
　　　 sell()内でループさせるようにする
　　　 確かにインスタンスメソッドはインスタンスが生成されていることが前提のため、
　　　 自身のインスタンスを自身が持つメソッドで引数に渡していてもおかしくはないか？

　よく考えたらpayment()ではファイルからアイテムIDに対応する値段を持ってくる処理が必要なため、
　sell()で返されるHashMapはアイテムID順にソートしてあると便利か？しかし結構難しそう
　別にソートは無くても良いと思うが、それだと例えば やくそう → まりょくのみず → やくそう の順で買った時に
　無駄な処理が一回増えてしまう。この例ならまだしも、同じような無駄な処理が何回増えるかは
　ユーザーによって変わるため、極力ここの処理は無駄を省けるようにはしたい。
　　→　思ってたよりアルゴリズムがわからなすぎるのでゲーム完成を優先

　そういえばマップはキーの重複が許されていない、つまりsell()メソッドの戻り値を考え直す必要がある
　もし購入処理段階ですでに買ったものをもう一度買う動作をした場合、マップ内のキーをチェックする
　処理を入れ、重複している場合はそこに値(購入数)を加算していく形はどうか？
　　→　既に同じアイテムを買っていた場合、マップの重複しているアイテムIDの値に
　　　 購入数を加算していく形で実装済み。

・br.readLine()でファイルの内容をそのままローカルのString変数にコピーしたい時、
　while(br.readLine() != null) のようにすると、条件式時点でreadLine()が実行されてしまうため
　行がとびとびになってしまう。これを解決するにはどうすればよいか？まあ今はpayment()内の
　拡張for文で一回一回ファイルを開く処理のまま進めてしまった方が良いとは思うが

・前whileは条件式を評価するのが最初なだけであって、while内の処理が終わった時点で
　条件式と違っていたらループをやめるのだろうか？

・勇者インスタンス自体を渡すことが可能だとわかったので、勇者自体の情報を渡したかったが
　断念した呪文、敵の行動、アイテムについても引数にthisを取ることにし、
　それに対応する内容に各クラスのメソッドの処理を変更する
　　→　敵の行動とアイテムについては実装済み

・呪文について、勇者インスタンスが渡せないと思い込んでいたため各呪文はメソッドという形で
　実装していたが、勇者の情報が渡せるのでアイテムと同じようにデータをファイルにまとめて
　各呪文のクラスファイルを作成してもよいのではないか？呪文もアイテムと同様、
　数が増えた時に今のようにメソッドでの実装だといちいち実装しなければならないが、
　データファイルに情報をまとめておけばそれを処理するメソッドがあれば
　データファイルを編集するだけで済む。
　　→　呪文のデータファイルを作成した。

・各呪文のクラスファイルを作成する。攻撃や回復処理のメソッドはHealSpellやAttackSpellなどの
　親クラスに実装し、各呪文クラスのメソッドでそれを利用する形をとる。
　　→　各呪文のクラスファイルを作成し、HealSpellやAttackSpellにポイント計算メソッドを実装済み。

・今のレベル + 1のデータと今の経験値を比べて、経験値の方が大きければレベルアップ
　データの方が大きければ何もせずレベルアップ処理を終了
　レベルアップした場合、また今のレベル + 1のデータと今の経験値を比べて…のようにしていく
　やはりwhileが必要、whileを抜ける条件は「今の経験値が次のレベルに必要なポイントに達さなかった場合」
　つまり　this.levelPoint < dataArray[1]　が真となった時
　ということはwhile (!this.levelPoint < dataArray[1])　で繰り返せる？
　　→　そんな感じで実装済み

・レベルアップしているかをチェックする処理としていた場合にレベルとステータスをアップする処理は
　分けた方が良さそうか？レベルアップのチェックはbooleanで返してその結果によって
　レベルアップ処理を行いたいが、レベルアップ前のレベルやレベルアップ前のステータスなどを
　どう表示するかが問題　レベルアップしているかを最も簡単に知るには自分の1つ上のレベルの
　必要経験値を経験値が超えたら、となる　これだけ記述してbooleanで返して、
　そっから必要な処理をしていけばよいのでは？
　　→　とりあえずレベルアップ処理は全て修正済み

・なぜか何も考えず「エラーが直るから」と言った理由でつけていたthrows IOExceptionを
　消し、例外処理が必要な個所にだけtry-catchを記述する
　　→　実行済み

・敵情報もデータファイルにまとめればよいのでは？そうすればコンストラクタにいちいち敵情報を
　書き込まなくていいだろうし、将来的に討伐モンスターリストとか実装する時に楽な気がする

・ファイルを読み込んでコンストラクタのひな形だけ作ってくれるようなプログラムを作りたい
　BronzeSword.java なら
// コンストラクタ
public BronzeSword() {

}
　だけ作ってくれるやつ

・そうび(つるぎ、かぶと、よろい)の各データを作成し、クラスファイルを作成する
　　→　作成済み

・勇者クラスのbattle()内で敵のターンカウントをプラスしていたが、
　e.turn()側でこれを行うことにする。(厳密にはe.turn()内の各敵行動メソッドの最後でplusTurnCount()を行う)
　逃げる判定もe.turnで行えばbattle()メソッドが見やすくなるかと思ったが、
　e.turnは敵によって種類が違うため、敵の数だけいちいちisRun()の処理を書かなければならない。
　このことについて追加で思ったのが、これから敵の数が増えた場合、その敵の数だけe.turnを
　実装するのは骨が折れるのでは？引数にその敵の行動パターンの種類数を渡したら、
　ランダムにどれかの数字を返してくれるようなプログラムがenemyクラスにあると便利？
　特技や特定の行動はstaticクラスにするのがよいか？そうすれば同じ特技を持つ敵ごとに
　いちいち実装しなくてよくなる(呪文も同じことが言えるような気がするが)

・状態異常クラスを作り、そのフィールド変数にboolean型で様々な状態異常を持つとする。
　それをbraveとenemyに継承させれば(バトルするキャラ、といった立ち位置で)
　とりあえず状態異常攻撃などは実現することができそう？問題は状態異常を治す処理をどう実装するか
　アイテムで例えば毒を治すアイテムだったりを実装したいが、use()をHpItemで実装してしまっているため
　状態異常を治すアイテムはいちいちuse()をオーバーライドしなければならない。
　それかアイテムデータファイルに「特殊効果」のような欄を作り、それを上手く使うか
　とりあえずやってみるのもいいかもしれない、やはり状態異常が無いと敵の攻撃パターンが
　飽き飽きしたものになってしまう。

　一気に状態異常を判別するにはどういったプログラムにすればよいか？
if (brave.getIsPoison) {
    brave.setHp(brave.getHp - 5);
}
if (brave.getIsCursed) {
    brave.setAttack(brave.getAttack / 2);
}

　のようにしていくととても手間がかかる。
　今回のゲームでは状態異常は重複しないものとする。ならばほしい情報はどの状態異常がtrueかということ。
　状態異常をフィールドではなくクラスの形で作り、現在の状態異常を返すメソッドを作ればよいのでは？
　何も状態異常が無ければ通常状態を返す、など
　public State returnState() みたいなメソッド

・BraveとEnemyの親クラスとしてBattleCharクラスを作成した。戦いに使われるステータスや
　状態を実装。それに伴って勇者クラスと敵クラスのthis.だったりの表記を修正する
　　→　修正済み

・状態異常をどのように実装するか？

getstate().effect; ←　毎ターンの最初にこんな感じで処理を入れればよいのでは？
getstate().getIsPoison()
getstate().getIsSleep()
if (getstate() != usually) みたいなことができると便利(状態が通常じゃなければ)
state.getUsually()

if (!getstate().getUsually) とすればいけるのでは？

　Stateインタフェースを作り、抽象メソッドとしてeffect()だけ記述する。
　それを各状態異常クラスで実装し、getstate().effect()とすれば
　状態の効果が現れるようにしたい。

brave.setState(new Poison());　のようにして状態異常は付与すればよいか？

　しかしねむりや麻痺などの状態はどうやってそのターンをスキップすればよいか？
　ねむりや麻痺のメソッド内でturnCountを++して、battle()の状態異常判定の後にも
　ターンカウント判定を持ってくればできそうだが、長ったらしい気がする。
　何かいい方法はないか？

　getstate().effectだと長くなってしまうため、やはり状態異常をもう一つ上にすることはできないか？
　ターンカウントを取得して、それをうまくつかってなんとかできないか？
　ターン最初のeffect()の後にターン休みフラグ判定を入れればできそうだが、
　またifが増えてしまい見づらくなる。battle()のdo-whileを前whileにして、その前に状態異常判定を
　持ってくればよいのでは？麻痺と眠りはターンカウントを+1する処理だけにし、
　その後while判定に行けばターンをスキップできるのでは？
　しかし思ったのだが、今のままのプログラムでは麻痺でターンを飛ばしているのか眠りターンを飛ばしているのか、
　つまり敵の状態異常をプログラム的に知るすべがない。これでは特定の状態異常の敵に
　通常より強いダメージを与える攻撃などの実装ができなくなってしまう。やはり
　isPoisonやisSleepなどのフラグをフィールドとして持っておくべきなのかもしれない。
　状態異常による処理はなんとかBattleChar内にメソッドを作るしかない。
　と思ったが、getState()で何のステータスが入っているかが分かれば今の実装でもよいのか？
　しかしそれを知る方法が良くわからない。if (brave.getstate().equals(Sleep))のようなことはできないだろうし
　state.get()で文字列を返すようにするか？麻痺ならisParalysisを返す
　　→　とりあえずStateクラス = 状態異常クラスとして、つうじょう、どく、ねむり、まひ、のろい、
　　　 のクラスファイルを作成した。

・battle()内で敵の状態異常処理判定の後にも勇者ターンのように何かしらturncountが+1されたか
　(ねむりやまひでターン休みなのか)を判定するプログラムが必要なのでは？今のままだと
　敵ターンが2ターン増加してしまい、バグとなることが推測される。
　敵は主人公と違って誰かが入力したりすることはないので状態異常処理とe.turnの間に
　turncountの動きがあったかを判定する処理さえあればよい。

　// enemy.getState().get == isPoison || enemy.getState().get == isSleep
　// 長いし、何よりこれからのゲーム作りで行動不能状態の種類が増えた時にもっと大変
　// やはり「ターン休みフラグ」を作った方が良いだろうか？
　// enemy.getState().get == notAction 
　if (!enemy.getState().get == notAction) {
　*      enemy.turn(this);
　* }
　* のような形にするのはどうか？
　* State_data.csbに新しく「状態異常の詳細」欄を作成し、
　* そこに「行動不能」「一定ターンダメージ」など
　* ジャンル分けして、getState().getでその詳細を返すようにすれば
　* if (enemy.getState().get == "行動不能") のようにできるか？
　　→　enemy.getState().effect(enemy);                     // 状態異常判定処理
        if (!(enemy.getState().getStateDetail() == "notAction")) {
            enemy.turn(this);                               // 敵ターン
        }
　　　 のようにプログラムを作成した。こうすれば、ターン休みの状態異常がないときにのみ
　　　 enemy.turn()が発動するようにできたはず。

・アイテムを使うuseItem()内で使用したアイテムの数を減らす処理を書き忘れていたので、
　.use()の後にdecrease()を追加した。

・せっかく敵にもMPがあるので、敵だけが使える呪文も作りたい(水系の呪文、麻痺や眠りなど)
　勇者はアイテムで敵を麻痺させたり眠らせることができるようにしたい

　敵の呪文を実装しようとしたが、勇者だけが使える呪文、敵だけが使える呪文、
　両者ともに使える呪文、というようなすみわけをするのが結構面倒では？
　ゲーム内で使われる呪文は全て1つのファイルにまとめ、それぞれが使う呪文は
　そのファイルから抽出して使うようにした方が良いはず
　ただ、1つのファイルにまとめた場合、勇者のレベルアップによる呪文習得プログラムは
　どのように行えばよいか？呪文のデータに「使用者」みたいな欄を追加し、レベルアップした際は
　その欄に勇者と書いてあるものを探し、チェックする。といった形はどうか？
　if (data.contains("勇者") || data.contains("共通"))　のようにして該当行を探す。
　というか使用可能レベルを用いて勇者が習得する呪文か判断すればよいのでは？
　この欄は敵には関係ないため、敵だけが使用する呪文のこの欄は0とかにしておく。
　そうすればif (dataArray[2] > 0) のように判断ができる？

・状態異常実装のためにBattleCharクラスを考え、そのクラスをBraveとEnemyに継承させたが
　呪文を敵も使えるようにした今、HealSpellとAttackSpellの引数をbraveとenemyから
　battlecharにするだけで共用できるようになったので、この「バトルに登場する人物」という
　くくりでBattleCharクラスを作ったのは良い判断だったと思う。

・敵が呪文を唱えてMPが足りなかった場合、どのようにターンカウントをプラスさせるか？
　　→ MPが足りないときの処理をtoStringでEnemyだった場合にplusTurnCount()するようにした。

・AbnormalitySpellクラスのresite()内で呪文ごとに「どくにおかされた！」
　「まひしてしまった！」などのテキストをそれぞれの呪文で適した表示させるにはどうすればよいか？
　ファイルからgetName()を引っ張ってきて、AbnormalitySpell内でswitch文にでもするか？
　　→ テキスト表示メソッドの引数にState型を渡し、メソッド内でState.getStateName()
　　　を使用して判別する。

・勇者も敵も状態異常になった時のテキストを一緒にしているが、これは一緒だと違和感があるのでは？
　主人公視点では敵は倒さなければならない者なのに、「〇〇(敵の名前)がまひしてしまった！」
　という文言はおかしい気がする。理想は勇者が状態異常になったら
　「まひしてしまった」「ねむってしまった」「どくにおかされた」だが、敵に対してこちらが付与したときは
　「まひさせた」「ねむらせた」「どくじょうたいにした」などにするべきでは？
　これはどうやって行えばよいか？
　例えばBattleChar型を引数にとってそれが勇者か敵かを判断したい時は
　クラスのtoString()を実装して、わかるようにすれば割といけそう

　しかし、勇者が敵に毒にされた場合、勇者が自分で毒になった場合(玄人向けのアイテムみたいな)
　敵が勇者に毒にされた場合、敵が自ら毒になった場合(敵の特性)
　これら4パターンの場合で表示テキストを変えたい。
　　→ Textクラスでこれらを判別することにした。自ら状態異常になった場合は
　　　勇者と敵でテキストは変わらず、相手を状態異常にした場合は
　　　if文でtoStringを用いてreceiverが勇者か敵かを判別している。

・勇者が呪文を唱えようとしてMPが足りないときは「MPがたりない！」でいいが、
　敵がMP不足で呪文を唱えられなかった場合、「MPがたりない！」では説明不足な気がする。
　「しかしMPがたりなかった！」などにしたい
　　→ 修正済み

・例えば、既に毒状態になっているところでまた毒状態になった場合、
　「〇〇はすでに どく じょうたいだ」のように表示したい。
　個人的に最初にくらった状態異常のターン数は固定にしたい。
　(既に毒状態のところに新しい毒状態が来たら持続ターンが上書きされる、というのは少し理不尽な気がする)
　それだと下手したらエンドレス状態異常になりかねないので最初に食らった状態異常のターンを固定したい。
　そうするにはどうすればよいか？そもそもすでにその状態なのかを確かめるプログラムを書く必要がある。
if (receiver.getStateName().equals("どく")) {
    System.out.println("〇〇はすでに どく 状態だ")
    return;
}
　のようにすればよいか？

　上記のようなプログラムは、状態異常を付与する攻撃や呪文全てに実装しなければならない。
　これはかなり手間がかかってしまう。どうにか状態異常側のプログラムでこれを判断する方法はないか？
　Battlechar()のsetstate()で見分ける方法はどうか？Stateクラスを継承している
　各状態異常のクラスにtoString()を実装し、
　　→ BattleCharのsetState()内で付与しようとしている状態異常が既になっている状態異常と同じの場合、
　　　「すでに〇〇じょうたいだ」のように表示し、スキップする処理を追加した。

・状態異常が終了する処理は、各状態異常のeffect()内で、引数にBattleCharそのものかターンカウントを受け取り、
　そのターンカウントとそれにランダムな数字(大体2～4)を加算したものを用意し、
　しかしこれだと無理ではないか？インスタンスメソッドは値を保存しておけない。
　やはりBattleCharのフィールドとして状態異常などは持っておいた方が良いのだろうか？
　それとも状態異常専用のフラグをBattleCharに持たせればよいか？
　状態異常をターン経過で治すのに必要な処理は
if (this.turnCount == abnormalityTurnCount) {
    setState(new Usually());
}
　状態異常が回復するのは今のところアイテムによる効果か、ターン経過のみ
　(本当は状態異常回復呪文も実装したいが今やったら頭がパンクする)
　つまりターン経過で治す処理ができたとしても、その判定前にアイテムによって治っているかどうかを
　判別する処理も入れなければならない。流れとしては以下か？
状態異常になった
↓
次のターン開始、状態異常効果
↓
自ターンでアイテムを使い回復
↓
まず状態異常が治っているかどうかを確認
↓
治っていたら無視、治っていなければ状態異常効果
↓
状態異常持続ターンが終わるかの確認
↓
終わっていなければ無視、終わっていたら状態異常を治して次へ

　Stateクラスのコンストラクタの引数にBattleCharをとり、その中でdecideAbnormalTurnPeriod()を実行すれば
　状態異常がセットされるときにnew IsPoison(brave) のようにして状態異常持続ターン上限を
　BattleCharのabnormalTurnPeriodフィールドに格納できるか？しかしこの場合、IsUsuallyの場合も
　ターン上限が適用されてしまうのでは？IsUsuallyはデフォルト状態のためターン上限などはない。
　これに対して、IsUsually状態は削除して通常状態はstateにnullを格納することで表現しようとしたが
　中身がnullのフィールドのインスタンスメソッドを呼び出そうとしたときにエラーが出そうなのでテストする。
　やはりnullPointerExceptionが出た。

　セットしようとしているのがIsUsuallyの場合の処理を実装すればよいか？
　状態異常ターン上限を迎えた時に状態異常を治すプログラムはsetState(new IsUsually())になるはず。
　そして状態異常ターン上限はStateクラスを継承した各状態クラスのコンストラクタで決定しようとしている。
　ならば、IsUsually()のコンストラクタを他と違うようにすればよいのでは？

　いや、Stateクラスのコンストラクタに実装しようとしていたのだった。そうしないと、
　状態異常の種類が増えた時にいちいち各状態クラスのコンストラクタにその処理を記述するよりも、
　大元のStateクラス1つに実装してしまった方が楽だから。なので今問題なのは
　「Stateクラスのコンストラクタで状態異常持続ターン上限を決めたいが、
　そうするとIsUsuallyのターン上限も決められてしまうこと」である。

　状態異常のコンストラクタが呼び出された時にその状態異常が何ターン続くのかを決めるため、
　各状態異常クラスのコンストラクタの引数にBattleChar(状態異常をくらう者)を取ることにし、
　anyone.decideAbnormalTurnPeriod();　のようにしてBattleCharの状態異常持続ターン上限を決める。
　そしてIsUsuallyについて思ったのが、状態異常の自然終了の判別を
　if (getTurnCount() == getAbnormalTurnPeriod)　で行うのならば、IsUsuallyがセットされたときは
　「状態異常持続上限ターン数を決定しない」ことでずっとつうじょう状態が維持できるのではないか、と思った
　例えばどくになった時のターン数が14、どくがなおるターン数が16だとしたら、
　if (getTurnCount() == getAbnormalTurnPeriod)　が真になるときはどちらも16。
　そのif文の中ではsetState(new IsUsually())　の処理が行われる。この時、IsUsuallyのコンストラクタが
　特に状態異常上限ターン数を決めなかったとき、abnormalTurnPeriodの値はここからずっと変わらず、
　this.turnCountだけが増加していく。つまり、if (getTurnCount() == getAbnormalTurnPeriod)　が
　真になることはなくなる。IsUsually

　if (getTurnCount() == getAbnormalTurnPeriod) で状態異常が終わるかの判定をしたいなら、
　abnormalTurnPeriodを決定する時は現時点のターンカウント + 乱数　という感じにしたらよさそう
　　→ 現在のターンカウント + 2-4の乱数 した数を状態異常が続く上限ターン数とし、
　　　それを用いてbattle()内で状態異常が終わるかどうかを判別することにした。

・状態異常が自然に治った時に「〇〇の どく じょうたいがなおった！」のように表示したい。
　　→ BattleCharクラスにhealAbnormalState()メソッドを作り、battle()の状態異常が治った箇所に
　　　このメソッドを記述した。

・状態異常をアイテムで治した時、状態異常判定周りをどうすればよいか？
　状態異常持続ターン上限を上手く操作すればいけるか？
　今問題だと思っているのは、「アイテムで状態異常を治したのに、2つのターンカウントが一致する時の判定文で
　じょうたいがなおった！ともう一度表示されてしまう」こと。ならばやはり状態異常を治すアイテムで行う処理は
　.setState(new Isusually())ではなく、状態異常ターン上限を現在のターンカウントにしてしまう処理では？
　例えば、どくになって現在7ターン目、毒が自然に治るのが9ターン目だとする
　このターンでどくけしそうを使い、setAbnormalTurnPeriodを8ターンにした。
　アイテムを使ったことで自分のターンは1つ進むので現在8ターン目、状態異常上限ターンも8ターン目となり
　自動的に状態異常が治る。アイテムの処理は状態異常上限ターンを現在のターン数+1に調整することにする。
　これをStateItemクラスに実装する。
　　→ 実装済み。

・状態異常アイテムを追加しようと考えた時に思ったのが、アイテムのデータファイルはやはり1つのファイルに
　まとめてしまった方が良いのではないか？せっかく大元のデータファイルを作っているのに
　いちいち各ジャンルのアイテムのデータファイルにまたまとめる作業は不要な気がする。
　それぞれのデータファイルで違ってくる欄は全て大元のデータファイルに追加してしまい、
　関係ない欄には「なし」というふうに書いてしまえばよい。ただし、あまりにもデータファイルが大きくなり、
　データファイルから検索する処理が原因でゲームが重くなってしまっているとかであれば
　手間をかけてでもジャンルごとにデータファイルを作成する意味はある。
　　→ アイテムデータファイルは1つにまとめ、HpItemとMpItemで行っていたデータファイルから
　　　フィールドにデータを読み込むコンストラクタの処理はItemクラスで行うこととした。

・アイテムデータファイルのターゲット値でHPとMP両方回復するやつは「HP&&MP」など書けば良いだろうか？
　余裕があればきせきのくすりはHPとMP、両方を回復できるようにしたい

・状態異常を治すアイテムを使う時、勇者がなっている状態と治そうとしている状態が合致しているかの
　判別が必要ではないか？どくじょうたいなのにめざましそうを使って状態異常が治ってしまっては困る。
　各アイテムに勇者の現状態を知る処理が必要。というかそれをStateItemクラスに実装したい。
　　→ 実装済み

・アイテムを使用する際、HPが満タンなのにHP回復アイテムを使おうとしていたり、
　状態異常もないのに状態異常を治すアイテムを使おうとする、または治そうとしているじょうたいと
　アイテムが治す状態が違う場合など、意味がないのに使おうとしている時に
　「このアイテムはいまはこうかがないようだ…」と表示したいので、各アイテムのuse()にこの処理を入れる。
　これに加えて、現段階ではbattleUseItem()側でターンカウントをプラスしているが、
　アイテムのuse()側でプラスした方がよさそう。
　　→ アイテムのuse()側でアイテムを使用したときにターンカウントをプラスすることにした。
　　　これに伴い、BraveのisUseItem()はアイテム使用可能かの判別とアイテム使用をこのメソッド内で
　　　一気に行っていたが、canUseItem()とuseItem()に分けることにした。

・状態異常を治すアイテムのクラスファイルを作成する。
　　→ 作成済み

・状態異常呪文と敵専用の呪文のクラスファイルを作成する。
　　→ 作成済み

・バトルが終了した後、変化したバトル用のステータスに元々のステータスを格納する処理を入れる。
　　→ 実装済み

・ぐんだんぎょはなかまとあつまってこうげきりょくをあげる行動を実装しようとしたときに思ったのが、
　攻撃アップ、ダウンなどステータスに関する状態異常はStateクラスを継承している状態異常たちとは
　別の枠で扱いたい。なぜなら、ステータス関係もsetState(new AttackUp)のようにしてしまったら
　状態異常が目まぐるしく変化してしまうからである。しかし、攻撃力アップなどを一度行ったら
　永続させるわけにもいかず、既存の状態異常と同じように持続ターン上限を決めて
　「こうげきりょくがもとにもどった！」のようにしたいので、なんとかこれについて実装する。

　まず、新しくAbilityStateクラスを作成する必要があるかどうかを考える。
　既にInBattleAttack(Defense,Agility)フィールドがあるので、それの上下と元に戻ったタイミングさえ
　わかれば別に新しく状態異常クラスは作成しなくてもよいのでは？
　状態異常のようにステータス上下持続ターン上限を付与して、それで判断するようにするか？
　private int abilityUpDownTurnPeriod
　しかしこうげき、ぼうぎょ、すばやさのどれに影響が及ぼされたのかをどう渡せばよいか？
　例えば、おおいなるきょじんのふみつぶすこうげきは確率で勇者の防御力を下げるものとする。

　ステータス上下は複数並行可能とする。すばやさはさがっているがこうげきはあがっている、など。
　すると、BattleCharにchangedAttack(Defense,Agility)TurnPeriod　のように3つフィールドを持てばよいか？
　しかし、例えば既に攻撃が下がっている状態で攻撃が上がるとなると、それはこうげきが「もとにもどる」ことになる。
　このような処理をどうするか？もしこうげきがさがっていれば、のような処理を入れれば可能ではあると思うが。

　こうげき、ぼうぎょ、すばやさの上下は2段階まで、倍率で言うとデフォルト値の0.5までとしたい。
　ということは、これ以上ステータスが　あがら/さがら　ない！　と表示するような処理も必要になる。
　現在のbattleステータスが0.5以下かどうかの判別について、javaではdouble型を(int)でキャストしたときに
　小数点以下は切り捨てられるため、これを利用して判別できそう。
　(agility * 0.75) + (agility * 0.25)　のようにすれば、元通りの数値になることを確かめた。
　ということは、if (getBattleAttack + (getDefaultAttack * 0.5) == getDefaultAttack)
　とすれば、「この条件式が真 = 現在のバトル攻撃力は2段階ダウンしている」　ことが分かる。
　いや待て、これは(int)でキャストしていない結果のため、実際はgetDefaultAttackより低くなるのでは？
　ということは　if (getBattleAttack + (getDefaultAttack * 0.5) < getDefaultAttack)
　とすればいけるだろうか？
        int agility = 23;
        int oneDownAgility = (int)(agility * 0.75);
        int twoDownAgillity = (int)(oneDownAgility * 0.75);
        
        System.out.println((agility * 0.75) + (agility * 0.25));
        System.out.println(oneDownAgility + (agility * 0.25));
        System.out.println((agility * 0.5) + (agility * 0.5));
        System.out.println(twoDownAgillity + (agility * 0.5));

　実行結果
        23.0
        22.75
        23.0
        23.5

　どうやら(num * 0.75) * 0.75　と　num * 0.5　は等しくないようだ。言われてみれば確かに。
　では1段階ダウンと2段階ダウンをどう実現するか？デフォルトステータスをあらかじめ4で割り、
　その数値を足したり引いたりする形はどうか？だが初期の方、

　よく考えるとステータスアップで考えられる形は結構な数が無いか？
　1段階アップだけでも「2段階ダウン時に1段階アップ」「1段階ダウン時に1段階アップ」「通常時に1段階アップ」
　「1段階アップ時に1段階アップ」「2段階アップ時に1段階アップ(これ以上アップしないようにチェック処理が必要)」
　このように、5段階ある。1段階なら単純なのでまだいいが、これが2段階になると
　「2段階ダウン時に2段階アップ」「1段階ダウン時に2段階アップ」「通常時に2段階アップ」
　「1段階アップ時に2段階アップ(1段階しかアップしない)」「2段階アップ時に2段階アップ(これ以上アップしない)」
　これを数字に直すと通常時を0として、-2,-1,0,1,2とできるのでやはりbyte型か何かのステータス変化のフラグを持って
　それでセットする形の方が良いだろうか？
　brave.setBattleAttackFlag(2)　→　攻撃2段階アップ　みたいな。
　この問題を解決するにあたって優先したいのは、仮に上下するステータスが増えたとしても
　なるべく楽で確実な方法をとること。どうすればそのような処理になるか？
　「現在のターゲットステータス状態を取得し、それに合わせた処理をする」というのが
　もっともよい方法だと思う。メソッドに上下させたいステータスの情報を渡し、
　そのステータスを取得して、2アップさせるなら2ダウン、1ダウン、通常時は問題なく2アップして
　1アップ時なら1だけアップ、2アップ時なら意味がない、という風にすればよいか？
　これならif elseif else でいけそう。BattleCharにこれを実装する。

　メソッドの引数に渡す変化させたいステータスの情報について、"すばやさ"のような文字列は
　できれば避けたい。ステータス上下させたいメソッドで全てその引数を手打ちしなければならないから。
　upOneStepStatus(brave.status)のように出来たら便利なのだが、
　すると、新たにstatusクラスを作成する必要がある。こうげき、ぼうぎょ、すばやさなどは
　クラスにする必要はないと考えている。ステータスと識別番号を紐づけたファイルを作成するのが
　無難そうなのでいったんそれでやってみる。しかし、ファイルから引っ張ってくる時に
　何の値で検索をかければよいのか？それは"こうげき"や"ぼうぎょ"などの「名前」である。
　つまりどちらにせよそれを指定する箇所がある。これを避けるには各ステータスが自身の名前を
　持つようなことをしなければならないが、ただのフィールドにそのような機能が思い当たらない。
　やはりステータスもクラスを作成した方が良いのだろうか？
　しかしそうすると、レベルアップのステータス上昇処理などはどうなる？
　フィールドとしては　this.status.attack　のような感じになる。
　「デフォルトのステータス値をフィールドとして持ち、バトル内のステータスをクラスで作成する」
　というのはどうか？そうすれば現段階で存在するデフォルトステータスの処理は変えないことができる。
　このクラス内でboolean型などを持ったりすればステータス変化のターン終わり計算などもできるかもしれない。

　twoDownValue,oneDownValue,defaultValue,oneUpValue,twoUpValue　のように
　それぞれの値をあらかじめフィールドに定義してしまった方が良いだろうか？
　それとも、BattleStateクラスのcheckValue()内で変数を定義して
　それと比較する形の方が良いだろうか？
　BattleStatus battleAttack = new BattleAttack(getDefaultAttack());
　BattleStatus battleDefense = new BattleDefense(getDefaultDefense());
　BattleStatus battleAgility = new BattleAgility(getDefaultAgility());

　上の処理をバトル開始時にいちいちやる必要がある？
　現段階ではtwoUpValue(),oneUpValue()…のように計5つ実装しようとしているが
　例えば2ダウン時に2アップするのと2アップ時に2ダウンするのは処理的には全く同じとなる。
　処理内容が重複しているため、もっと簡単にできるはず。それについて考えたい。
　例えば、changeStatus(int chengeNum) のようにし、引数には-2,-1,0,1,2のどれかを取る。
　その引数を用いて計算をするなど。まあその場合changeStatus()を呼び出す側で引数にミスタイプしてしまったら
　意味ないのだが。changeStatus(brave.getBattleAttack.twoUp) のようにするか？
　それかこのプログラム用の定数をどこかで決めるか。
　if (2ダウン時に1アップ || 1ダウン時に1アップ || 1アップ時に1ダウン || 2アップに2ダウン) {
    system.out.println("こうげきがもとにもどった！")
}
　のようにすればよいか？

　確かにこうげきが1アップするという点については、ふつうから1アップと2アップから1ダウンは同じだが、
　文面も「こうげきがすこしあがった！」で統一するのは絶対に違う。
　確かに最終的には少し上がった状態になるのだが1ダウンは相対的に見れば下がっているのだから、
　1ダウンの時だけは違う文を表示したい。

　checkValueの値と引数にとっているステータス上下を表す値を足し算すれば最終的に
　ステータスがどの位置になるのかわかるのでは？今が-1、引数に2があるなら足して1、
　つまり攻撃は少し上がることを意味する。今が0、引数に1なら足して1なのでこれも同じ。
　こうすれば少しプログラムが見やすくなるか？
　↑の考えのようにして確かにプログラムが見やすくなったが、新たな問題が出てきた。
　このやり方では (valueCheck() + changeValueStep = 最終ステータス値) の形で判別を行っているが、
　たとえば、2アップ時に1アップするのは「3」、そして1アップ時に2アップするのも「3」となる。
　しかしこの2つで表示したい文は違う。なぜなら、2アップ時に1アップはもうあがりきらない結果しかないが、
　1アップ時に2アップだと1アップはしているのだ。つまりその1アップを伝えたい。
　この違いはどうやって記述するか？
　　→ ステータス上下について、「バトル時のステータス」クラスを作成し、
　　　そのクラスにおいて上下させるメソッドなどを実装した。

・ステータス上下について、BattleCharのsetterでいちいちbrave.setInBattleDefense(brave.getInBattleDefense…)
　のようにするのは長ったらしいので、上下したステータスを元に戻すメソッドとしてrestoreAttack()のようなもの、
　そして上がる倍率、下がる倍率を渡せば自動的に計算して上下させるメソッドを作る
　　→ 作成済み

・バトルステータスを初期化、復元する処理を修正済み。

・ステータスセットの処理を実装することはできたが、次に考えなければならないのは
　ステータス上下のターン上限を決める処理である。これを判別する処理は状態異常と同じく
　battle()内で行うか？
　状態異常(どくやまひ)は重複しないから「状態異常かどうか」で判別できていたが、
　ステータス上下の場合、こうげき、ぼうぎょ、すばやさどれかが上下していたら
　「ステータス上下している」になるので、普通にやったら判別処理が長くなってしまう。
　何かいい方法はないか？
BattleStatus battleAttack = new BattleAttack(this).
if (!battleAttack.value == getDefaultAttack) {

}
if (!this.battleAttack.getTurnPeriod == 0) みたいな感じで判別するか？

if (this.battleAttack.getIsChanged()) {
    if (this.battleAttack.getTurnPeriod() == getTurnCount()) {
        this.battleAttack.changedDefault();
    }
}
if (this.battleDefense.getIsChanged()) {
    if (this.battleDefense.getTurnPeriod() == getTurnCount()) {
        this.battleDefense.changedDefault();
    }
}
if (this.battleAgility.getIsChanged()) {
    if (this.battleAgility.getTurnPeriod() == getTurnCount()) {
        this.battleAgility.changedDefault();
    }
}
　→ 上記の処理をBattleCharクラスにstatusUpDown()メソッドとして実装した。
　　これでステータス上下を判別できるはず？

・例えば、勇者の防御が1アップしている状態でおおいなるきょじんの防御を下げるプログラムが
　働いたときに、現段階だときょじんがわのプログラムでsetIsChanged()を行っているため、
　通常状態に戻っているのにisChangedがtrueになってしまう。
　これを避けるには、他のところで通常状態に戻った時はfalseのままと処理を書くか、
　あるいはbattle()内の判別処理内で状態が0の場合の処理を記述するか
　　→ BattleStatusのchangedStatus()内で0以外になった場合に
　　　this.isChanged = true　とした方がよさそう。

###20240405###

・BattleStatusのメソッドについて、getCurrentValue()だと長いので、getValue()に変更した。

・いちいち敵それぞれの行動の最後にplusTurnCount();を書くようにするのはやはり忘れそうで良くない
　(なんなら実際のろわれたたいぼくのsuffer()メソッドに記述を忘れていた)
　なので、battle()の方でplusTurnCount()した方が良いのではないか？
　　→ そのように修正した。まひとねむりはeffect()内でplusTurnCount()してしまうので、
　　　BraveかEnemyかを判別する処理を入れ、
　　　Braveならターンカウントをプラスして(Brave側はbattle()内でplusTurnCountしていないため)
　　　Enemyなら状態異常ターンカウントをプラスする処理のみ行う、と言った形にした。

・現段階ではメソッドは全てpublicにしているが、例えばenemyのcalculateDamage()のように
　継承するクラス以外は使わないメソッドについてはprotectedにするべきでは？

・せっかくメモをこの形で保存しているので、日付ごとに分けたらいつのタイミングで
　どんな修正を行ったのかが分かりやすい気がするので、一応本日から日付をつけることにした。
　###yyyyMMdd###の形で最初につける。
　1つ上の「現段階ではメソッドは全てpublicにしているが」と書いたときに
　「これ後から見返しても"現段階"がいつだったかわからんよな…」となったのがきっかけ。

###20240407###

・今のままだと敵が使える技の種類がなかなか限られてしまう(勇者が相手のこうげきりょくやぼうぎょりょくを
　さげることができないので、こうげきが2アップするなどは理不尽になってしまう)ので、
　勇者にできることも増やしたい。アイテムや呪文などで敵をデバフできるようにしたい。
　そうすれば、敵の行動パターンも少し種類を増やしたり強くしても大丈夫なはず。

　それに伴って、敵にも状態異常が効きやすい敵、効きづらい敵を調整したい。
　あとは抜け道をつくるためにかなり強い敵でも実はこの状態異常が効くとか。
　とりあえずこれはデバフ呪文やアイテムを実装した後でよい。

・しかしなるべくはやくゲームを完成させたいという考えもある。
　自分が思っているよりもはるかにデバッグに時間がかかると思っているため。
　　→ やはり優先すべきは全体プログラムの完成、勇者の行動を広げるのは後にし、とにかく先に進むことにした

・森、海、山ごとに敵データファイルを分けてそれぞれの継承用クラス(ForestEnemyなど)のコンストラクタで
　このデータファイルからプログラム変数にデータを格納する処理を書いているが、
　これは別にEnemyクラスで行って、データファイルも一括にまとめてしまってもよいのでは？
　そしてどのマップの敵なのかはそういった欄を作ればよい。

・上記に加えて思ったのが、各マップのcreateEnemy()について
　今のままでは敵の数が増えた時にいちいちそのマップの敵を把握していなければならない。
　これは絶対よくないので敵データファイルを読み取って自身のマップの敵だけを出現させるようなプログラムを作りたい。

・[進捗]defense()について経過ターン数を用いた判定の実装
　　　　敵のアイテムドロップについて考える
　　　　「そうびショップ」を作成する
　　　　ファイルから読み込んで表示するテキストを整える処理を考える
　　　　全ての敵ファイルを実装する
　　　　protectedやprivateにした方が良いメソッドのアクセス修飾子を変更する
　　　　ラスボスを考える
　　　　敵データファイルを一括でまとめる → 取組中
　　　　マップのcreateEnemy()をデータファイルから敵情報を読み取る形にする
　　　　勇者が使える呪文やアイテムに敵デバフのものを実装する
　　　　敵の状態異常のかかりやすさを調整するプログラムを考える

=========================================================================================================

ゲームのフロー

どのマップに行きますか？(mapChoose) → 選ばせる(return)
↓
選んだ数字に該当するマップを決める(仮に森だとする) → 選んだ答えによって決める(chooseMap,switch文？)
↓
森にやってきた！ → 表示する(system.out.println)
↓
勇者はどうする？(mapAction,while) → 選ばせる(return)
↓
選択肢によって行動が変わる(仮にsearchEnemyとする) → 選んだ答えによって決める(switch → battle)
↓
敵と戦う(Battle) → Battleの中で行動を選ばせる(while内でswitch) → 敵か勇者のHPが0になったら繰り返し終了
↓
戦いが終わる
↓
勇者はどうする？(mapAction,while)
↓


=========================================================================================================

ミスや引っかかったこと、つまずいたことやわからないこと

・import map;としてもimport文にエラーが出現し、mapパッケージのファイルが読みこめない。
　import map.Mapやimport spell.Spellだとちゃんと認識してくれる。
　だけどいちいちattackspellやhealspellとかもimportで記述しないといけないのは面倒。
　　→ そもそもimport文は「import パッケージ名.クラス名」のようにクラス名まで記述する必要があるため、
　　　import map;のように「import クラス名;」でエラーが出るのは当然。単に基礎知識不足だった。
　　　「import Map.*」や「import spell.*」とすることによって解決。

・「Unhandled exception type IOException」のエラーが出る
　　→ 例外処理を記述しないといけないエラー。上記のIOExceptionだとファイルを開く処理の際に
　　　もしファイルが開けないなどのエラーが出た場合にどうするかを記述しなければならない。
　　　public void a() throws IOException {} のようにすれば呼び出し元に例外を投げる動きをし、
　　　まだやっていないのでわからないがtry catchを記述すればエラーが出なくなるはず(try catch書かなきゃ)

・パッケージ構造が合っているのに「does not match the expected package ""」のようなエラーが出る
　　→ 最初にファイルを作成した位置と現在位置が違う際に出ることが分かった。
　　　vscode側でファイルの移動が反映されていないことによるエラーだと推測される。
　　　正しい位置で新しいファイルを作成することで解決。(本来はequipmentフォルダ配下に置きたい
　　　Equipment.javaファイルをその位置で作り直す、のような感じ)

・BattleStatusクラスのcheckValue()で現在のステータスがどの状態(2ダウン、1アップなど)にあるのかを
　調べる処理を書くため、以下のようにすると3行目で「case expressions must be constant expressions」
　のエラーが出た。
        final int TWO_DOWN_VALUE = (int)(value * 0.5);
        switch(this.value) {
            case TWO_DOWN_VALUE:
　　→ どうやらswitch文内でフィールドを使用できないらしい。なのでif-elseに変えるのが解決法となる。
　　　case節に

・

=========================================================================================================

将来的に作るプログラム、ゲームでやりたいこと

・討伐モンスターリストを作る
・コンストラクタのひな形を自動作成する(同時にアクセサもできたらなおよい)
・特技の実装
・基準のHPを下回ると、行動パターンが変化する(大体は強くなる)
・